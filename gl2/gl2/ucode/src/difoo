attributes.c
++++++++++++++++++++++++++++++++++++++++++++
block.c
++++++++++++++++++++++++++++++++++++++++++++
attributes.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
151c151
< 	    COND(IFZ); NEXT(DISPLAYB_WE); SEQ(JUMP);
---
> 	    COND(IFZ); NEXT(DISPLAYB_WE);
block.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
buffcopy.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
char.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
103,104d102
< 	_NS LOADMAR(_CHARPOSN); CONST(_CHARPOSN); _ES
< 
108c106
< 	_NS REGREG(ZERO,0,_ZERO); COND(IFZ); SEQ(RETN); _ES
---
> 	_NS REGREG(ZERO,0,_ZERO); COND(IFZ); DOJUMP(RETN_FROM_Z); _ES
111c109,110
< 	_NS REGHOLD; GEGET; _ES		/* otherwise discard stereo X, Z  */
---
> 	_NS IMMREG(ANDRS,0,_TEMP); CONST(_ALTDEPBIT); GEGET; _ES	 
> 					/* look at Depth mode */
113c112,113
< 	_NS REGREG(ZERO,0,_ZERO); GEGET; SEQ(RETN); _ES
---
> 	_NS REGREG(ZERO,0,_ZERO); COND(IFNZ); DOJUMP(DEPTH_CHARPOSN); _ES
> 					/* go if depthcue mode */
115,126c115,141
< /**********************************************************************
<  *
<  *	The following two states replace the state:
<  *
<  *	_NS RAM(RAMWR,_ZERO,HOLD);
<  *	 COND(IFFALSE); SEQ(THWB); NEXT(DISPATCH);_ES
<  *
<  *	which caused a stack overflow because the THWB with a
<  * false condition does not pop the stack. All that is wanted here
<  * is a stack pop to clean up.
<  *
<  **********************************************************************/
---
> 	_NS REGHOLD; GEGET; DOJUMP(RETN_FROM_Z);_ES
> 				/* zbuffer, discard z and return */
> 
> label(DEPTH_CHARPOSN)
> 	_NS LOADMAR(_DEPTH_PARAMS); CONST(_DEPTH_PARAMS); _ES
> 				/* else, assume depthcue and do a*z+b */
> 
> 	_NS SETSOP(NONQOP,0,RAMRD); ALUOP(SONLYOP,P0);
> 	 YQ(FF,LDQ,REGWRD); INCMAR; DOJSUB(GET_Z_INT); _ES
> 				/* "a" to Q reg; go get Z value */
> 				/* and calc I2 = a * Z + b */
> 
> 	_NS REGREG(MOVE,_I2,_I2); BPC(SETCOLORAB); _ES
> 				/* set as color of characters */
> 
> 	_NS LOADMAR(_COLOR); CONST(_COLOR); _ES
> 
> 	_NS RAM(RAMWR,_I2,INC);_ES	/* save color	*/
> 
> 	_NS RAM(RAMWR,_I2,HOLD); _ES	 /* in both places */
> 
> label(RETN_FROM_Z)
> 	_NS LOADMAR(_CHARPOSN); CONST(_CHARPOSN); _ES
> 				/* return pointing to character position */
> 
> 	_NS SEQ(RETN); _ES
> 
144,155d158
< /**********************************************************************
<  *
<  *	The following two states replace the state:
<  *
<  *	_NS RAM(RAMWR,_ZERO,HOLD);
<  *	 GEGET; COND(IFFALSE); SEQ(THWB); NEXT(DISPATCH); _ES
<  *
<  *	which caused a stack overflow because the THWB with a
<  * false condition does not pop the stack. All that is wanted here
<  * is a stack pop to clean up.
<  *
<  **********************************************************************/
chdraw.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
copyfont.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
33d32
< 	_NS REGCOMP(GT,_SRC,_DST); _ES
34a34,36
> 	_NS REGCOMP(GT,_SRC,_DST); COND(IFNEG); DOJUMP(COP_EXIT); _ES	
> 				/* if (nwds-1) < 0 leave now */
> 
69a72
> label(COP_EXIT)
copypixels.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
cursor.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
dbzline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
depthvec.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
diag.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
68c68
< 	_NS LOADMAR(_MASKLIM); CONST(_MASKLIM); _ES
---
> 	_NS LOADMAR(_MASKEOL); CONST(_MASKEOL); _ES
dispatch.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
divide.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
338,339c338,341
< 	_NS REGREG(SUBRSC,_ZERO,_TMP); DOJUMP(TEST_NUM); _ES
< 					/* negate num, go retest _NUM */
---
> 	_NS REGREG(SUBRSC,_ZERO,_TMP); _ES
> 					/* negate num */
> 	
> 	_NS REGREG(MOVE,_DEN,_SAVE); _ES
345,346c347,350
< 	_NS REGREG(SUBRSC,_ZERO,_SAVE); DOJUMP(TEST_DEN); _ES
< 					/* negate num, go retest _DEN */
---
> 	_NS REGREG(SUBRSC,_ZERO,_SAVE); _ES
> 					/* negate num */
> 
> 	_NS REGCOMP(GE,_TMP,_SAVE); _ES
fixchar.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
hitrept.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
ldivide.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
250,251c250,253
< 	_NS REGREG(COM2,_SAVE,_SAVE); DOJUMP(FTEST_DEN); _ES
< 					/* negate num, go retest n>d */
---
> 	_NS REGREG(COM2,_SAVE,_SAVE); _ES
> 					/* negate num */
> 
> 	_NS REGCOMP(GE,_TMP,_SAVE); _ES
low.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
1c1,24
< /* lowmem.c	--         Initialization / Selftest	<< GF2/UC4  >>
---
> /* ldivide.c
>  *
>  *	divide routines:
>  *		DIVIDE
>  *		LONGDIVIDE
>  *		DIVIDE16
>  *		LONGDIVIDE16
>  *
>  *	plus "long" division subroutine
>  *
>  *	Enter with outreg containing a pointer to a parameter area:
>  *
>  *	--->	 dividend, integer part
>  *		[dividend, fractional part]	(LONG versions only)
>  *		 divisor (integer)
>  *		 quotient, integer part
>  *		 quotient, fractional part
>  *
>  *	Routines return with MAR pointing at quotient fraction, no registers
>  *	disturbed.
>  *
>  * 2's complement, 4-quadrant division of an integer+fraction by an integer
>  *	producing an integer part
>  *	and a PREC bit fractional part. (no sign bit)
3a27,46
> #define PREC 12		/* number of significant bits in fraction result */
> 
> /* Fractional result is right-justified in word. Binary point is to right
>  *  of bit 2**PREC.  No sign bit in fraction.
>  * The first step is to divide the integer part of the dividend by the divisor
>  *	to produce an integer and a 15-bit (left-flush) fraction.
>  * Then the fractional part of the dividend is divided to produce another
>  *	fraction.  These two results are added to produce the final answer.
>  *
>  * Consult 2903 data book for details of integer division algorithm.
>  *	This algorithm was then tweaked to achieve the necessary postamble
>  *	for the operation REM/DEN => QUOfract.
>  *
>  *	USAGE:  dividend in _REM,_FRACT (destroyed)
>  *		divisor  in _DEN
>  *		constant: _ZERO
>  *		working regs: _TMP, _SAVE
>  *		results: INT part in _TMP, FRACT part in _SAVE
>  */
> 
7a51,60
> #include "fbc.mic.h"
> 
> #define _REM	14
> #define _DEN	13
> #define _SAVE	12
> #define _TMP	11
> #define _QUOI	10
> #define _QUOF	9
> #define _NUMSAV 8
> #define _FRACT	7
9c62,64
< #define _SCRATCHSIZE	4095
---
> ldivide()
> {
> newfile("ldivide.c");
11,12c66,67
< #define UNDEFINED	REGREG(ANDOP,P0,0,0); SEQ(JUMP); NEXT(UNDEF_TRAP)
< /*	 rejection of unimplemented command vectors	*/
---
> label(LDIVIDE)				/* test entry point */
> 	_NS REGHOLD; GEGET; _ES
14,15c69
< #define UNIMPLEMENTED	REGREG(ANDOP,P0,0,0); SEQ(JUMP); NEXT(UNIMPL_TRAP)
< 		/*	inform host of unimplemented command		*/
---
> 	_NS LOADREG(_REM,ALL16,MORE); _ES
17,20c71
< #define REGNOP	REGREG(ANDOP,P0,0,0)
< #define CLRZERO	SETROP(0,NONE); SETSOP(NONQOP,_ZERO,RAMNOP); \
< 		ALUOP(FLOWOP,P0); FTOYANDQ(FF,LDQ,REGWRE)
< 						/*	conveniences	*/
---
> 	_NS LOADREG(_FRACT,ALL16,MORE); _ES
22,24c73
< lowmem()
< {
< newfile("lowmem.c");
---
> 	_NS LOADREG(_DEN,ALL16,NOMORE); _ES
26,27c75
< declare(dummy2)
< declare(dummy1)
---
> 	_NS LOADMAR(_SAVE1); LDOUT; CONST(_SAVE1); _ES
28a77
> 	_NS RAM(RAMWR,_REM,INC); _ES
30c79
< label(PASS_THRU)	/* follows dispatch.c */
---
> 	_NS RAM(RAMWR,_FRACT,INC); _ES
32,38c81
< /*	handle PassThru command words. The left byte contains N, the
<  *	number of words (beyond fbc cmd) passed.
<  *	Save this in a reserved register
<  *	for commands that need to know it.
<  */
< 	  _NS LOADREG(_PASSN,LO8,NOMORE); _ES
< 					/* exact N count into ls byte	*/
---
> 	_NS RAM(RAMWR,_DEN,HOLD); DOJSUB(LONGDIVIDE16); _ES
40,41c83
< 	  _NS REGNOP; GEOMENGDATA; SEQ(JUMP); NEXT(DISPATCH); _ES
< 				/* get new command	*/
---
> 	_NS RAM(RAMRD,_TMP,HOLD); LDOUT; INTERRUPTHOST; _ES
42a85,86
> label(DISPLA_REST)
> 	_NS REGHOLD; DECMAR; _ES
44,47c88
< label(UNDEF_TRAP)
< 	_NS LOADIMM(0,_INTILLEGAL); DOTOOUTREG; INTERRUPTHOST; COND(IFFALSE);
< 	 SEQ(JUMP); CONST(_INTILLEGAL); _ES
< 				/* tell host about illegal instruction	*/
---
> 	_NS RAM(RAMRD,_TMP,HOLD); LDOUT; INTERRUPTHOST; DOJUMP(GETCMD); _ES
49,51c90,93
< label(UNDEFCONT)
< 	_NS LOADREG(0,ALL16,NOMORE); DOTOOUTREG; INTERRUPTHOST; _ES
< 			/*  put illegal code into out reg for host to read */
---
> 
> /*================================================================*/
> /*  LONGDIVIDE16
> /*================================================================*/
53c95,96
< 	_NS LOADDI(OUTPUTREG); REGNOP; COND(IFFALSE); SEQ(CJPP); _ES
---
> label(LONGDIVIDE16)
> 	_NS LOADMAR(_REGSAVE); CONST(_REGSAVE); _ES
55,57c98
< label(UNDEF_LOOP)
< 	_NS REGNOP; GEOMENGDATA; SEQ(JUMP); NEXT(UNDEF_LOOP); _ES
< 						/* flush pipe forever */
---
> 	_NS RAM(RAMWR,7,INC); DOJSUB(STM8UP); _ES
58a100
> 	_NS REGREG(ZERO,0,_ZERO); _ES
60,63c102,104
< label(UNIMPL_TRAP)
< 	_NS LOADIMM(0,_INTUNIMPL); DOTOOUTREG; INTERRUPTHOST; COND(IFFALSE);
< 	 SEQ(JUMP); CONST(_INTUNIMPL); _ES
< 				  /* report unimplemented command  */
---
> 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,_TMP,RAMNOP);
> 	 ALUOP(MOVE); YQ(FF,OLDQ,REGWRE); LDMAR;
> 	 COND(IFFALSE); SEQ(CJPP); _ES		/* load MAR with param ptr */
65c106,107
< 	_NS REGNOP; SEQ(JUMP); NEXT(UNDEFCONT); _ES	/* go trap	*/
---
> 	_NS IMMREG(ADD,4,_TMP); LDOUT; CONST(4); _ES
> 						/* fix up pointer for later */
66a109
> 	_NS RAM(RAMRD,_REM,INC); _ES
68c111
< label(INIT_START)
---
> 	_NS REGREG(MOVE,_REM,_NUMSAV); _ES	/* save numerator */
70,72c113,114
< /*	tests some basic machine functions, then initializes scratch ram
<  *	if machine healthy, "1" left in outreg; otherwise sequence infloops.
<  */
---
> 	_NS RAM(RAMRD,_FRACT,INC); COND(IFNNEG); DOJUMP(REGULAR_DIV); _ES
> 		/* get fract; point to DEN; if num pos, skip next junk */
74,76c116,117
< 	_NS REGREG(RONLYOP,P0,_ZERO,0); DOTOMAR(LOAD); COND(IFNZ);
< 	 SEQ(JUMP); NEXT(V00); _ES	/* clear MAR; copy 0 to reg. 0	   */
< 		/* if reg. not cleared by instruc. 0, go trap (test IFNZ)   */
---
> 	_NS REGHOLD; COND(IFZ); DOJUMP(REGULAR_DIV); _ES
> 			/* if num is exact neg intgr, do normal divide */
78,79c119
< 	_NS REGREG(SUBSROP,P0,0,_ZERO); COND(IFNEG); SEQ(JUMP); NEXT(V00); _ES
< 			/* decrement _ZERO to -1; test alu sign bit	*/
---
> 	_NS REGREG(INCR,_REM,_REM); _ES	/* else int part needs to be 2s comp*/
81,83c121,124
< 	_NS REGREG(RONLYOP,P1,_ZERO,_ZERO); SETLED; DOTOOUTREG;
< 	 COND(IFNNEG); SEQ(JUMP); NEXT(V00); _ES
< 	   /*  inc _ZERO to 0, load outreg (LED set); test for sign bit set */
---
> label(REGULAR_DIV)
> 	_NS RAM(RAMRD,_DEN,INC); DOJSUB(INT_DIVIDE); _ES
> 				/* start test for zero-divide */
> 				/* go divide - result in _TMP, rem in _REM */
85,86c126,128
< 	_NS REGREG(FHIGHOP,P0,0,_ZERO); COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES
< 			/* test previous increment operation	*/
---
> 	_NS REGREG(MOVE,_REM,_SAVE); DOJSUB(FRACT_DIV_16); _ES
> 			/* save "whole" remainder - go do fract part */
> 			/* result in _SAVE */
88,90c130
< 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,_ZERO,RAMNOP);
< 	 ALUOP(RONLYOP,P0); FTOYANDQ(FF,OLDQ,REGWRE);COND(IFFALSE); SEQ(CJPP); _ES
< 		/* recycle outreg into _ZERO */
---
> 	_NS REGREG(MOVE,_TMP,_QUOI); _ES
92,93c132,134
< 	_NS REGNOP; COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES
< 		/* test for correct DI bus enabling, outreg loading	*/
---
> 	_NS SETROP(_SAVE,NONE); SETSOP(NONQOP,_QUOF,RAMNOP);
> 	 ALUOP(MOVE); YQ(FLL,OLDQ,REGWRE); DOJSUB(DO_DBL_FRACT); _ES
> 		/* save results away (fract left just'd); go do fract */
95,96c136,137
< 	_NS REGREG(FHIGHOP,P0,0,_ZERO); SEQ(JSUB); NEXT(STM15UP); _ES
< 		/* test ram write, jsub; go write ones to ram loc. 0	*/
---
> label(FINISH_LDIV16)
> 	_NS RAM(RAMWR,_QUOI,INC); _ES
98,99c139,141
< 	_NS CLRZERO; SEQ(JSUB); NEXT(LM15UP); _ES
< 		/* clear reg, go read ones back in			*/
---
> 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(NONQOP,_QUOF,RAMWR);
> 	 ALUOP(MOVE); FTODO; LDMAR; CONST(_REGSAVE); _ES
> 			/* while writing out fract, load adr of save area */
101,102c143
< 	_NS CLRZERO; COND(IFZ); SEQ(JUMP); NEXT(V00); _ES
< 						/* test results and IFZ	*/
---
> 	_NS RAM(RAMRD,7,INC); DOJSUB(LM8UP); _ES
104,105c145,147
< /* byteswap and carryin mux test */
< 	_NS REGREG(FHIGHOP,P0,0,1); _ES		/* A = -1 */
---
> 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,0,RAMNOP);
> 	 ALUOP(MOVE); FTODO; LDMAR;
> 	 COND(IFFALSE); SEQ(CJPP); _ES
107c149,157
< 	_NS REGREG(FLOWOP,P0,0,3); _ES		/* C = 0  */
---
> 	_NS REGHOLD; SEQ(RETN); _ES
> 				/* load MAR, pt to fract, exit */
> 
> /*================================================================*/
> /*  LONGDIVIDE
> /*================================================================*/
> /* tiny difference - rightshift fract 4 places. */
> label(LONGDIVIDE)
> 	_NS LOADMAR(_REGSAVE); CONST(_REGSAVE); _ES
109c159
< 	_NS REGREG(RONLYOP,P1,3,2); _ES		/* B = 1  */
---
> 	_NS RAM(RAMWR,7,INC); DOJSUB(STM8UP); _ES
111,112c161,212
< 	_NS LOADDI(OUTPUTREG); SETROP(1,LO8); SETSOP(NONQOP,4,RAMNOP);
< 	 ALUOP(RONLYOP,P0); FTOYANDQ(FF,OLDQ,REGWRE);
---
> 	_NS REGREG(ZERO,0,_ZERO); _ES
> 
> 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,_TMP,RAMNOP);
> 	 ALUOP(MOVE); YQ(FF,OLDQ,REGWRE); LDMAR;
> 	 COND(IFFALSE); SEQ(CJPP); _ES		/* load MAR with param ptr */
> 
> 	_NS IMMREG(ADD,4,_TMP); LDOUT; CONST(4); _ES
> 						/* fix up pointer for later */
> 
> 	_NS RAM(RAMRD,_REM,INC); _ES
> 
> 	_NS REGREG(MOVE,_REM,_NUMSAV); _ES	/* save numerator */
> 
> 	_NS RAM(RAMRD,_FRACT,INC); COND(IFNNEG); DOJUMP(REG_DIV); _ES	
> 							/* point to DEN */
> 
> 	_NS REGHOLD; COND(IFZ); DOJUMP(REG_DIV); _ES
> 			/* int is exact neg int - do  normally */
> 
> 	_NS REGREG(INCR,_REM,_REM); _ES
> 
> label(REG_DIV)
> 	_NS RAM(RAMRD,_DEN,INC); DOJSUB(INT_DIVIDE); _ES
> 				/* start test for zero-divide */
> 				/* go divide - result in _TMP, rem in _REM */
> 
> 	_NS REGREG(MOVE,_REM,_SAVE); DOJSUB(FRACT_DIV_16); _ES
> 			/* save "whole" remainder - go do fract part */
> 			/* result in _SAVE */
> 
> 	_NS REGREG(MOVE,_TMP,_QUOI); _ES
> 
> 	_NS SETROP(_SAVE,NONE); SETSOP(NONQOP,_QUOF,RAMNOP);
> 	 ALUOP(MOVE); YQ(FLL,OLDQ,REGWRE); DOJSUB(DO_DBL_FRACT); _ES
> 		/* make into left-justified fract ; go div fract part */
> 
> label(FINISH_LDIV)
> 	_NS LOADDI(UCONST); RAM(RAMWR,_QUOI,INC); SEQ(LDCT); CONST(3); _ES
> 
> label(RSHIFT4)
> 	_NS SETROP(_QUOF,NONE); SETSOP(NONQOP,_QUOF,RAMNOP);
> 	 ALUOP(MOVE); YQ(FLR,OLDQ,REGWRE); SEQ(RPCT); NEXT(RSHIFT4); _ES
> 						/* right-shift fract */
> 
> 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(NONQOP,_QUOF,RAMWR);
> 	 ALUOP(MOVE); FTODO; LDMAR; CONST(_REGSAVE); _ES
> 			/* while writing out fract, load adr of save area */
> 
> 	_NS RAM(RAMRD,7,INC); DOJSUB(LM8UP); _ES
> 
> 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,0,RAMNOP);
> 	 ALUOP(MOVE); FTODO; LDMAR;
114d213
< 				/* outreg holds 0 - make a word 0xff00 */
116,118c215,217
< 	_NS SETSOP(NONQOP,4,RAMNOP); ALUOP(SONLYOP,P0); YTODO(SWAP);
< 	 FTOYANDQ(FF,OLDQ,REGWRD); DOTOOUTREG;    /* 0x00ff into outreg */
< 	 COND(IFNNEG); SEQ(JUMP); NEXT(V00); _ES   /* test 0xff00 for neg */
---
> 	_NS REGHOLD; SEQ(RETN); _ES
> 				/* load MAR, pt to fract, exit */
> 
120,122c219,221
< 	_NS LOADDI(OUTPUTREG); SETROP(0,ALL16); SETSOP(NONQOP,4,RAMNOP);
< 	 ALUOP(ADDOP,P1); FTOYANDQ(FF,OLDQ,REGWRE);
< 	 COND(IFFALSE); SEQ(CJPP); _ES	/* 0xff00 + 0x00ff + 1 = 0 */
---
> /*================================================================*/
> /* 	fractional part subroutine
> /*================================================================*/
124,126c223,226
< 	_NS SETROP(2,NONE); SETSOP(NONQOP,1,RAMNOP); ALUOP(ADDOP,P0);
< 	 FTOYANDQ(FF,OLDQ,REGWRD); PROPOUT12;		/* A + B = 0 */
< 	 COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES	/* check prev result */
---
> label(DO_DBL_FRACT)
> 	_NS SETROP(_FRACT,NONE); SETSOP(NONQOP,_TMP,RAMNOP);
> 	 ALUOP(MOVE); YQ(FF,LDQ,REGWRE); _ES
> 			/* load Q with numerator to prep for integer divide */
128,130c228
< 	_NS SETROP(3,NONE); SETSOP(NONQOP,3,RAMNOP); ALUOP(RONLYOP,P0);
< 	 FTOYANDQ(FF,OLDQ,REGWRD); PROPIN;	/* try prop'g a 1 (C+ci)*/
< 	 COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES	/* check for lsw = 0	*/
---
> 	_NS REGREG(MOVE,_NUMSAV,_NUMSAV); _ES	/* test true sign of num */
132,133c230,232
< 	_NS REGREG(ADDOP,P0,2,1); PROPOUT16;		/* A += B (=0 lsw) */
< 	 COND(IFZ); SEQ(JUMP); NEXT(V00); _ES		/* check for cin=1 */
---
> label(FTEST_NUM)
> 	_NS REGREG(ZERO,0,_REM); COND(IFNNEG); DOJUMP(FTEST_POS); _ES
> 			/* if numerator >=0, no negation. Smear msw. */
135,136c234
< 	_NS REGREG(RONLYOP,P0,3,3); PROPIN;	/* C += Cin(1) (=1 msw) */
< 	 COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES	/* check for 0 lsw result */
---
> 	_NS REGREG(ONES,0,_REM); _ES			/* neg smear msw */
138,140c236,237
< /* now A = 0    B = 1    C = 1  */
< 	_NS REGREG(RONLYOP,P0,1,1); PROPOUT12;	/* try prop'g a 0 */
< 	 COND(IFZ); SEQ(JUMP); NEXT(V00); _ES	/* check for 1 msw result */
---
> 	_NS REGREG(COM2,_TMP,_TMP); DOJUMP(FTEST_FRAC); _ES
> 		/* negate num */
142c239,240
< 	_NS REGREG(RONLYOP,P0,1,1); PROPIN; _ES	/* prop 0 into msw */
---
> label(FTEST_POS)
> 	_NS REGREG(MOVE,_TMP,_TMP); _ES	/* look at "sign" of fract */
144,145c242,244
< 	_NS REGREG(SUBRSOP,P1,1,2); PROPOUT16;	/* A - B = -1 lsw */
< 	 COND(IFNZ); SEQ(JUMP); NEXT(V00); _ES	/* check for 0 cin to msw */
---
> label(FTEST_FRAC)
> 	_NS REGREG(MOVE,_DEN,_SAVE); COND(IFNEG); DOJUMP(FDO_INT_DIV); _ES
> 		/* save & test denom; if fract still "neg" it's big */
147,148c246,248
< 	_NS REGREG(SUBRSOP,P0,3,1); PROPIN;	 /* C - A - 1 + Cin = 0 msw */
< 	 COND(IFNNEG); SEQ(JUMP); NEXT(V00); _ES /* check for -1 lsw */
---
> label(FTEST_DEN)
> 	_NS REGCOMP(GE,_TMP,_SAVE); COND(IFNNEG); DOJUMP(FTEST_INT); _ES
> 			/* compare num and denom; skip if denom not neg */
150c250,251
< /*   now initialize scratch parameters	*/
---
> 	_NS REGREG(COM2,_SAVE,_SAVE); _ES
> 					/* negate num */
152,153c253
< 	_NS LOADMAR(1); COND(IFFALSE); SEQ(JUMP); CONST(1); _ES
< 						/* address low ram	*/
---
> 	_NS REGCOMP(GE,_TMP,_SAVE); _ES
155,156c255,259
< 	_NS LOADDI(UCOUNT); REGNOP; SEQ(PUSH); CONST(_ENDINIT-1); _ES
< 					/* clear bottom scratch consts */
---
> label(FTEST_INT)
> 	_NS REGREG(MOVE,_FRACT,_SAVE); COND(IFGE); DOJUMP(FDO_INT_DIV); _ES
> 			/* if num > denom, must do integer phase;
> 			 * test num in order to sign-smear;
> 			 * save it for postamble */
158c261,263
< 	_NS RAM(RAMWR,_ZERO,INC); SEQ(LOUP); _ES
---
> 	_NS SETROP(0,NONE); SETSOP(NONQOP,_TMP,RAMNOP);
> 	 ALUOP(ZERO); YQ(FF,LDQ,REGWRE); DOJUMP(DFRACADD); _ES
> 		/* zero Q reg & result and skip (we know quo is 0) */
160c265,267
< /*  GF2 scratch ram is always the same -- report it */
---
> label(FDO_INT_DIV)
> 		/* now doubleword dividend is in _REM | Q... divisor in _DEN
> 		 */
162,163c269,270
< 	_NS LOADIMM(_TEMP,_SCRATCHSIZE); DOTOOUTREG;
< 	 COND(IFFALSE); SEQ(JUMP); CONST(_SCRATCHSIZE); _ES
---
> 	_NS DIVFIRST(_DEN,_REM); /*LOADDI(UCOUNT);*/ DOPUSH(13); _ES
> 				/* first divide cycle (calc sign of quo) */
165,166c272,273
< 	_NS LOADIMM(_TEMP,_ENDOFSCRATCH); CONST(_ENDOFSCRATCH); _ES
< 					/* end of non-table scratch area */
---
> 	_NS DIV(_DEN,_REM); SEQ(LOUP); _ES
> 				/* iterate (integer) divide cycles */
168c275
< 	_NS LOADMAR(_HITSTACKPTR); COND(IFFALSE);SEQ(JUMP); CONST(_HITSTACKPTR); _ES
---
> 	_NS DIVCOR(_DEN,_REM); _ES
170c277,279
< 	_NS RAM(RAMWR,_TEMP,INC); _ES		/* save in HITSTACKPTR	*/
---
> 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(QOPERAND,0,RAMNOP);
> 	 ALUOP(ORRS); YQ(FF,LDQ,REGWRD); CONST(1); _ES
> 				/* correction to correction! "or" one to Q */
172,174c281
< 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(NONQOP,_TEMP,RAMWR);
< 	 ALUOP(RONLYOP,P0); FTOYANDQ(FF,OLDQ,REGWRD);
< 	 DOTOMAR(LOAD);  CONST(_MASKLIM); _ES	/* and in HITSTACKLIM   */
---
> /* integer postamble (straight from the 2903 book) */
176c283
< 	_NS RAM(RAMWR,_TEMP,HOLD); _ES		/* and in MASKLIM */
---
> 	_NS REGREG(MOVE,_REM,_REM); _ES		/* examine remainder */
178c285,287
< 		/* end of initialization	*/
---
> 	_NS SETROP(_NUMSAV,NONE); SETSOP(NONQOP,_REM,RAMNOP);
> 	 ALUOP(ANDRS); FTODO; COND(IFZ); DOJUMP(DFRACDONE); _ES
> 		/* if rem=0, skip postamble; test sign of saved num & rem */
180c289,291
< /*********** central command fetch ***************/
---
> 	_NS REGCOMP(EQ,_DEN,_REM); COND(IFNNEG); DOJUMP(FNORMCHK); _ES
> 			/* if both non-neg, go do normal correction check;
> 			 * first half of magnitude check */
182,183c293,295
< label(GETCMD)
< 	 _NS REGNOP; GEOMENGDATA; SEQ(JUMP); NEXT(DISPATCH); _ES
---
> 	_NS SETROP(_DEN,NONE); SETSOP(NONQOP,_REM,RAMNOP);
> 	 ALUOP(ADD); FTODO; COND(IFEQ); DOJUMP(FEQMAG); _ES
> 			/* other half of magnitude check (neg divisor) */
185c297,300
< label(OUTSEND)	/* let host spy on outreg; inc MAR */
---
> 	_NS SETROP(0,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(SONLYOP,P0);
> 	 YQ(FF,OLDQ,REGWRE); COND(IFEQ); DOJUMP(FEQMAGNXT); _ES
> 				/* if equal mag, go test Q for special corr;
> 				 * save integer quo in TEMP */
187,188c302,306
< 	_NS LOADDI(OUTPUTREG); REGNOP; COND(IFFALSE); SEQ(CJPP); _ES
< 						/* enable outreg read  */
---
> label(DFRACDONE)
> 	_NS SETROP(0,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(SONLYOP,P0);
> 	 YQ(FLL,OLDQ,REGWRE); COND(IFOVF); DOJUMP(OVERFLO); _ES
> 			/* save final integer quotient in TEMP register */
> 			/* with final left shift */
190c308,311
< 	_NS REGNOP; DOTOMAR(INC); SEQ(RETN); _ES  /* inc MAR and return */
---
> label(DFRACADD)
> 	_NS REGREG(ADD,_TMP,_QUOF); PROPOUT16; COND(IFNEG);DOJUMP(NEGADD);_ES
> 				/* add two fractional parts together */
> 				/* if frac neg, go sign smear msw */
192,196c313,314
< #ifdef NOZSCAN
< label(ZSHADESCANLINE)
< label(ZSCAN_INIT)
< 	_NS REGNOP; SEQ(JUMP); NEXT(UNIMPL_TRAP); _ES
< #endif
---
> 	_NS REGREG(MOVE,_QUOI,_QUOI); PROPIN; SEQ(RETN); _ES
> 			/* propagate to integer part */
198,200c316,318
< label(FREE_HIGH_2K)	/* to be called by user code (rev 2.3 & later) */
< #ifdef _DIVTAB_VALID
< 	_NS LOADMAR(_SAVE2); CONST(_SAVE2); _ES
---
> label(NEGADD)
> 	_NS REGREG(SUBSR,_ZERO,_QUOI); PROPIN; SEQ(RETN); _ES
> 			/* tricky: quoi+(-1)+cin = quoi-(0)-1+cin */
202,205c320,322
< 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(NONQOP,0,RAMWR);
< 	 ALUOP(MOVE); FTOYANDQ(FF,OLDQ,REGWRE);
< 	 DOTOMAR(LOAD); CONST(_DIVTAB_VALID); _ES
< 		/* save reg 0, point to flag */
---
> /*================================================================*/
> /* 	postamble branches
> /*================================================================*/
207d323
< 	_NS REGREG(FLOWOP,P0,0,0); _ES	/* make a 0 */
209,212c325,328
< 	_NS LOADDI(UCONST); SETROP(0,ALL16); SETSOP(NONQOP,0,RAMWR);
< 	 ALUOP(MOVE); FTOYANDQ(FF,OLDQ,REGWRE);
< 	 DOTOMAR(LOAD); CONST(_SAVE2); _ES
< 		/* write a 0, point to saved value */
---
> label(FNORMCHK)
> 	_NS SETROP(_REM,NONE); SETSOP(NONQOP,_NUMSAV,RAMNOP);
> 	 ALUOP(ORRS); FTODO; _ES
> 				/* check if remainder and dividend positive */
214,217c330,357
< 	_NS RAM(RAMRD,0,HOLD); SEQ(RETN); _ES
< #else
< 	_NS REGNOP; SEQ(RETN); _ES
< #endif
---
> 	_NS SETROP(0,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(SONLYOP,P0);
> 	 YQ(FF,OLDQ,REGWRE); COND(IFNNEG); DOJUMP(DFRACDONE);_ES
> 					/* if so, exit; examine and save Q */
> 
> 	_NS REGHOLD; COND(IFNEG); DOJUMP(FADDONE); _ES
> 						/* if Q neg, correct +1	*/
> 
> label(FSUBONE)
> /*	_NS REGREG(ADD,_DEN,_REM); _ES		/* correct remainder */
> 
> 	_NS SETROP(_ZERO,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(SUBSR);
> 	 YQ(FF,LDQ,REGWRE); DOJUMP(DFRACDONE); _ES
> 		 				/* correct Q is Q-1; exit */
> 
> label(FEQMAG)
> 	_NS SETROP(0,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(MOVE);
> 	 YQ(FF,OLDQ,REGWRE); _ES
> 
> label(FEQMAGNXT)
> 	_NS REGHOLD; COND(IFNEG); DOJUMP(FSUBONE); _ES
> 				/* decrement negative quotients (corr A) */
> 
> label(FADDONE)
> /*	_NS REGREG(SUBSRC,_DEN,_REM); _ES	/* correct remainder */
> 
> 	_NS SETROP(0,NONE); SETSOP(QOPERAND,_TMP,RAMNOP); ALUOP(SONLYOP,P1);
> 	 YQ(FF,LDQ,REGWRE); DOJUMP(DFRACDONE); _ES
> 						/* correct Q is Q+1; exit */
lowmem.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
201a202
> label(Z_VEC_DRAW)
203a205,211
> 
> #ifdef NORUNLEN
> label(RUN_LENGTH)
> label(READ_RUNLENGTH)
> 	_NS REGNOP; SEQ(JUMP); NEXT(UNIMPL_TRAP); _ES
> #endif
> 
modes.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
116c116
< 	 COND(IFNZ); DOJUMP(WRTPOLYMODE); _ES	/* if it is, skip ahead   */
---
> 	 COND(IFNZ); DOJUMP(ZPOLYMODE); _ES	/* if it is, skip ahead   */
118c118,124
< 	_NS REGREG(XOR,_MODEMASK,_POLYFLAGS); _ES /* if not, clear the bit */
---
> 	_NS REGREG(XOR,_MODEMASK,_POLYFLAGS);
> 	 DOJUMP(WRTPOLYMODE); _ES		/* if not, clear the bit */
> 
> label(ZPOLYMODE)
> #ifdef NOZPOLY
> 	_NS REGHOLD; DOJUMP(UNIMPL_TRAP); _ES
> #endif
mvppixels.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
pixels.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
points.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
readpixels.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
readrun.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
243d242
< 
runlen.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
stm.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
vectors.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
viewport.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zvectors.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
addsentinels.c
addsentinels.c
advance.c
advance.c
1,3c1
< 
< /* advance.c
< /*	advance
---
> /*	add_sentinels
4a3,5
> /*	puts flag values and addresses on either end of the vertex list
> /*	and send the stipple pattern address to the BPC 
> /*
12a14,15
> 		_TEMP,
> 		_LASTPT
14,36c17,19
< 	ADVANCE_S2D
< 		_XLEFT_HI
< 		_XLEFT_LO
< 		_COLOR_LEFT_HI
< 		_COLOR_LEFT_LO
< 		_XRIGHT_HI
< 		_XRIGHT_LO
< 		_COLOR_RIGHT_HI
< 		_COLOR_RIGHT_LO
< 
<     constants used
< 		none
<     
<     scratch locations used
< 		_SCR_DEL_XLEFT_HI
< 		_SCR_DEL_XLEFT_LO
< 		_SCR_DEL_COLOR_LEFT_HI
< 		_SCR_DEL_COLOR_LEFT_LO
< 		_SCR_DEL_XRIGHT_HI
< 		_SCR_DEL_XRIGHT_LO
< 		_SCR_DEL_COLOR_RIGHT_HI
< 		_SCR_DEL_COLOR_RIGHT_LO
< 
---
>    constants used
> 		_STARTLIST
> 		_BIGNEG
39c22
< advance()
---
> add_sentinels()
41c24
< newfile("advance.c");
---
> newfile("addsentinels.c");
43,47c26
< label(ADVANCE_S2D)
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_RIGHT_HI, _COLOR_RIGHT_HI, DEC);
< 	PROPIN;
<     _ES
---
> label(ADD_SENTINELS)
49,51c28,33
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XRIGHT_LO, _XRIGHT_LO, DEC);
< 	PROPOUT16;
---
>     _NS /* load _TEMP with the address of the start of the list and
> 	increment the address to the correct location, this is done
> 	so BIGNEG is only loaded once */
> 	IMMREG(RONLYOP, P0, _STARTLIST+4, _TEMP);
> 	CONST(_STARTLIST+4);
> 	DOTOMAR(INC);
54,56c36,39
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XRIGHT_HI, _XRIGHT_HI, DEC);
< 	PROPIN;
---
>     _NS /* write the address of the beginning of the list next, and
> 	decrement the address to the correct position for the flag
> 	value */
> 	RAM(RAMWR, _TEMP, DEC);
59,61c42,44
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_LEFT_LO, _COLOR_LEFT_LO, DEC);
< 	PROPOUT16;
---
>     _NS /* load _TEMP with BIGNEG */
> 	IMMREG(RONLYOP, P0, _BIGNEG, _TEMP);
> 	CONST(_BIGNEG);
64,66c47,49
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_LEFT_HI, _COLOR_LEFT_HI, DEC);
< 	PROPIN;
---
>     _NS /* write BIGNEG to the next location to flag the end of the
>         vertex list */
> 	RAM(RAMWR, _TEMP, INC);
69,71c52,54
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XLEFT_LO, _XLEFT_LO, DEC);
< 	PROPOUT16;
---
>     _NS /* load the MAR with the address of the start of the list */
> 	LOADMAR(_STARTLIST);
> 	CONST(_STARTLIST);
74,77c57,58
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XLEFT_HI, _XLEFT_HI, DEC);
< 	PROPIN;
< 	SEQ(RETN);
---
>     _NS /* write the flag value in there */
> 	RAM(RAMWR, _TEMP, INC);
80,137c61,67
< /*****************************************************/
< /*****************************************************/
< /*****************************************************/
< 
< label(ADVANCE_S_Z)
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _Z_RIGHT_HI_ZS, _Z_RIGHT_HI_ZS, DEC);
< 	PROPIN;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_RIGHT_LO, _COLOR_RIGHT_LO, DEC);
< 	PROPOUT16;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_RIGHT_HI, _COLOR_RIGHT_HI, DEC);
< 	PROPIN;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XRIGHT_LO, _XRIGHT_LO, DEC);
< 	PROPOUT16;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XRIGHT_HI, _XRIGHT_HI, DEC);
< 	PROPIN;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _Z_LEFT_LO_ZS, _Z_LEFT_LO_ZS, DEC);
< 	PROPOUT16;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _Z_LEFT_HI_ZS, _Z_LEFT_HI_ZS, DEC);
< 	PROPIN;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_LEFT_LO, _COLOR_LEFT_LO, DEC);
< 	PROPOUT16;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _COLOR_LEFT_HI, _COLOR_LEFT_HI, DEC);
< 	PROPIN;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XLEFT_LO, _XLEFT_LO, DEC);
< 	PROPOUT16;
<     _ES
< 
<     _NS	/* finish updating the deltas */
< 	REGRAM(ADDOP, P0, _XLEFT_HI, _XLEFT_HI, DEC);
< 	PROPIN;
---
>     _NS /* write the address of the end of the list now, also
> 	increment _LASTPT in case we have to reverse the order of Z and
> 	shade */
> 	ALUOP(RONLYOP, P1);
> 	SETROP(_LASTPT, NONE);
> 	SETSOP(NONQOP, _LASTPT, RAMWR);
> 	FTOYANDQ(FF, OLDQ, REGWRE);
141d70
< 
bumpindex.c
bumpindex.c
1,2c1
< /* bump_index.c
< /*	bump_left_index and bump_right_index
---
> /*	add_sentinels
3a3,4
> /*	puts flag values and addresses on either end of the vertex list
> /*	and send the stipple pattern address to the BPC 
13,16c14,15
< 	BUMP_LEFT_INDEX and BUMP_RIGHT_INDEX
< 		_LEFT,
< 		_RIGHT,
< 		_BIASED_DONE
---
> 		_TEMP,
> 		_LASTPT
18a18
> 		_STARTLIST
20d19
< 
23c22
< bump_indexes()
---
> add_sentinels()
25c24
< newfile("bump_index.c");
---
> newfile("addsentinels.c");
27,31c26
< label(BUMP_LEFT_INDEX)
<     _NS /* test the address for end of list, incrementing the MAR to
<     	point at the address of the other end if this is true */
< 	IMMRAMCOMP(NQ,_BIGNEG,INC); CONST(_BIGNEG);
<     _ES
---
> label(ADD_SENTINELS)
33,52c28,32
<     _NS /* if the above values were equal then its end of list,
< 	also test left vs. right in the hope that we're not at end of
< 	list */
< 	REGCOMP(EQ, _LEFT, _RIGHT);
< 	COND(IFNQ);
< 	SEQ(JUMP);
< 	NEXT(NOT_END);
<     _ES
< 
<     _NS	/* if were here then we have reached end of list and must load
< 	left with the value of the other end of the list,
< 	also load the MAR with this value for use on return */
< 	RAM(RAMRD, _LEFT, LOAD);
<     _ES
< 
<     _NS /* retest for all the points being used up */
< 	REGCOMP(EQ, _LEFT, _RIGHT);
< 	SEQ(JUMP);
< 	NEXT(NOT_END);
< 	/* increment the MAR to point at the Y coord */
---
>     _NS /* load _TEMP with the address of the start of the list and
> 	increment the address to the correct location, this is done
> 	so BIGNEG is only loaded once */
> 	IMMREG(RONLYOP, P0, _STARTLIST+4, _TEMP);
> 	CONST(_STARTLIST+4);
56,59c36,39
< label(BUMP_RIGHT_INDEX)
<     _NS /* test the address for end of list, incrementing the MAR to
<     	point at the address of the other end if this is true */
< 	IMMRAMCOMP(NQ,_BIGNEG,INC); CONST(_BIGNEG);
---
>     _NS /* write the address of the beginning of the list next, and
> 	decrement the address to the correct position for the flag
> 	value */
> 	RAM(RAMWR, _TEMP, DEC);
62,68c42,44
<     _NS /* if the above values were equal then its end of list,
< 	also test left vs. right in the hope that we're not at end of
< 	list */
< 	REGCOMP(EQ, _LEFT, _RIGHT);
< 	COND(IFNQ);
< 	SEQ(JUMP);
< 	NEXT(NOT_END);
---
>     _NS /* load _TEMP with BIGNEG */
> 	IMMREG(RONLYOP, P0, _BIGNEG, _TEMP);
> 	CONST(_BIGNEG);
71,74c47,49
<     _NS	/* if were here then we have reached end of list and must load
< 	left with the value of the other end of the list,
< 	also load the MAR with this value for use on return */
< 	RAM(RAMRD, _RIGHT, LOAD);
---
>     _NS /* write BIGNEG to the next location to flag the end of the
>         vertex list */
> 	RAM(RAMWR, _TEMP, INC);
77,79c52,54
<     _NS /* retest for all the points being used up */
< 	REGCOMP(EQ, _LEFT, _RIGHT);
< 	DOTOMAR(INC);
---
>     _NS /* load the MAR with the address of the start of the list */
> 	LOADMAR(_STARTLIST);
> 	CONST(_STARTLIST);
82,86c57,58
< label(NOT_END)
<     _NS	/* if the values are not equal then return without setting the
<     	done flag, also move the MAR along to the next scratch location */
< 	SEQ(RETN);
< 	COND(IFNQ);
---
>     _NS /* write the flag value in there */
> 	RAM(RAMWR, _TEMP, INC);
89,95c61,67
<     _NS /* if we're here then we've reach end of list and the done flag
<     	must be set */
< 	IMMREG(IOROP, P0, 0x8000, _BIASED_DONE);
< 	CONST(0x8000);
<     _ES
< 
<     _NS
---
>     _NS /* write the address of the end of the list now, also
> 	increment _LASTPT in case we have to reverse the order of Z and
> 	shade */
> 	ALUOP(RONLYOP, P1);
> 	SETROP(_LASTPT, NONE);
> 	SETSOP(NONQOP, _LASTPT, RAMWR);
> 	FTOYANDQ(FF, OLDQ, REGWRE);
checkmask.c
checkmask.c
addsentinels.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
advance.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
bumpindex.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
checkmask.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
computeslope.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
dbzfillline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
dbzshadeline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
filltrapzoid.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
finishside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
getfrstsds.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
polyclose.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
279a280,286
> 
> #ifdef NOZPOLY
> label(ZFILL_TRAP)
> label(GET_FIRST_SIDES_S_Z)
> 	_NS REGHOLD; DOJUMP(UNIMPL_TRAP); _ES
> #endif
> 
polydraw.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
220c220
< 	REGCOMP( GE, _TOPY, _YTHIS);
---
> 	REGCOMP( LT, _TOPY, _YTHIS);
272,273c272,273
< 	REGCOMP( GT, _BOTTOMY, _YTHIS);
< 	SEQ(RETN);
---
> 	REGCOMP( GE, _BOTTOMY, _YTHIS);	/* allow bottom to be equal */
> 	SEQ(RETN);			 /*  after a new left */
389d388
< 	SEQ(RETN);
390a390,448
> 
>     _NS LOADMAR(_ALTPOLYMODE); CONST(_ALTPOLYMODE); _ES
> 
>     _NS IMMRAM(ANDRS,_ALTDEPBIT,_TEMP,HOLD); CONST(_ALTDEPBIT); _ES
> 				/* look at depthcue mode */
>     
>     _NS REGHOLD; COND(IFZ); SEQ(RETN); _ES
> 				/* return if not depthcue mode */
> 
>     _NS IMMRAM(ANDRS,_ALTZBUBIT,_TEMP,HOLD); CONST(_ALTZBUBIT); _ES
> 				/* look at zbuffer mode */
>     
>     _NS REGHOLD; COND(IFNZ); DOJUMP(POLY_GET_ZDEP); _ES
> 				/* go if depthcue-zbuffer mode */
> 
> label(POLY_GET_DEP)
> 
>     _NS /* point to (lastpt-2) to write shade out */
> 	LOADDI(UCONST);
> 	SETROP(0,ALL16);
> 	SETSOP(NONQOP,_LASTPT,RAMNOP);
> 	ALUOP(SUBSRC); FTODO;
> 	CONST(2);
> 	DOTOMAR(LOAD);
>     _ES
> 	
>     _NS RAM(RAMWR,_PREVSHADE,HOLD); _ES
> 		    /* rewrite shade value */
> 
> label(POLY_GET_ZDEP)
> 	_NS LOADMAR(_DEPTH_PARAMS); CONST(_DEPTH_PARAMS); _ES
> 				/* begin setting up to do I1 calculation */
> 
> 	_NS SETSOP(NONQOP,0,RAMRD); ALUOP(SONLYOP,P0);
> 	 YQ(FF,LDQ,REGWRD); INCMAR; _ES
> 				/* "a" to Q reg; go get Z value */
> 				/* and calc CURSHADE = a * Z + b */
> 
> 	_NS REGREG(ZERO,0,_CURSHADE); LOADDI(UCOUNT); SEQ(LDCT); CONST(14); _ES
> 
> label(POLY_GET_Z1)
> 	_NS ALUOP(ZERO); FTODO; _ES	/* make sure DCOUT is clear next */
> 
> 	_NS MUL(_ZTHIS,_CURSHADE); SEQ(RPCT); NEXT(POLY_GET_Z1); _ES
> 
> 	_NS MULLAST(_ZTHIS,_CURSHADE); LOADDI(UCONST); DOPUSH(1); _ES
> 
> /* binary point is two bits down from top of lsw, so doubleshift left 2 */
> 	_NS SETROP(_CURSHADE,NONE); SETSOP(NONQOP,_CURSHADE,RAMNOP);
> 	     ALUOP(MOVE); YQ(FLL,QL,REGWRE); SEQ(LOUP); _ES
> 
> 	_NS REGRAM(ADD,_CURSHADE,_CURSHADE,HOLD); BPC(SETCOLORAB); _ES
> 				/* set as color of characters */
> 
> 	_NS LOADMAR(_COLOR); CONST(_COLOR); _ES
> 
> 	_NS RAM(RAMWR,_CURSHADE,INC);_ES	/* save color	*/
> 
> 	_NS RAM(RAMWR,_CURSHADE,HOLD); SEQ(RETN); _ES	 /* in both places */
polyexit.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
14c14
< #include "gl2cmds.h"
---
> #include "gl2/gl2cmds.h"
60,61c60
<     _NS /* compare the command with the command for move poly and set
<     	intensity */
---
>     _NS /* compare the command with the command for move poly */
shadeline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
shadetrap.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
shfinishside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
shgetfrstsds.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
864a865,892
>     _NS /* load the MAR with the address of the polygon stipple pattern,
> 	syncronize */
> 	LOADMAR(_POLYSTIPADR);
> 	CONST(_POLYSTIPADR);
>     _ES
> 
>     _NS /* read polystipadr first to set flag */
> 	ALUOP(SONLYOP, P0);
> 	SETROP(0, NONE);
> 	SETSOP(NONQOP, 0, RAMRD);
> 	FTOYANDQ(FF, OLDQ, REGWRD);
> 	DOTOOUTREG;
> 	BPCCMD(NOOP);		/* syncronize */
>     _ES
> 
>     _NS /* send polystipadr to the BPC and jump on value */
> 	ALUOP(SONLYOP, P0);
> 	SETROP(0, NONE);
> 	SETSOP(NONQOP, 0, RAMRD);
> 	FTOYANDQ(FF, OLDQ, REGWRD);
> 	DOTOOUTREG;
> 	BPCCMD(LOADFA);
> 	COND(IFNZ);		/* if _POLYSTIPADR != 0, set AllPattern Bit */
> 	SEQ(JUMP);
> 	NEXT(ALL_PATTERN);
>     _ES
> 
> /* _POLYSTIPADR == 0, no AllPattern Bit */
870,872c898,901
<     _NS /* now syncronize by doing a NOOP, read the configuration */
< 	ALUOP(SONLYOP, P0);
< 	SETROP(0, ALL16);
---
>     _NS /* force the line stipple bit on, also force the write increment on
>     	CD write to the read configuration */
> 	ALUOP(IOROP, P0);
> 	SETROP(0, ALL16); LOADDI(UCONST); CONST(0x180);
876c905
< 	BPCCMD(NOOP);
---
> 	BPCCMD(LOADCONFIG);
878a908,920
>     _NS 
> 	SEQ(JUMP);
> 	NEXT(END_ALL_PATTERN);
> 	REGHOLD;
>     _ES
> 
> label(ALL_PATTERN)
> /* _POLYSTIPADR != 0, set AllPattern Bit */
>     _NS /* load the address of the CONFIG register */
> 	LOADMAR(_CONFIG+1);
> 	CONST(_CONFIG+1);
>     _ES
> 
882,883d923
< /***********************************************************************
<    For 2.3.1, 0x2180 ==> 0x180. Fixes half speed gouraud problem.
885,889c925
<      AllPattern doubled line draw speed. 
<      However, patterned gourauds won't work now.
<  ***********************************************************************/
< 	SETROP(0, ALL16); LOADDI(UCONST); CONST(0x180);
< 	SETSOP(QOPERAND, 0, RAMNOP);
---
> 	SETSOP(NONQOP, 0, RAMRD);
894a931
> label(END_ALL_PATTERN)
896,897c933,934
< 	REGHOLD;
< 	DOTOMAR(DEC);
---
> 	LOADMAR(_CONFIG);	/* point to mode register */
> 	CONST(_CONFIG);
945,959d981
<     _ES
< 
<     _NS /* load the MAR with the address of the polygon stipple pattern,
< 	syncronize */
< 	LOADMAR(_POLYSTIPADR);
< 	CONST(_POLYSTIPADR);
<     _ES
< 
<     _NS /* send it to the BPC */
< 	ALUOP(SONLYOP, P0);
< 	SETROP(0, NONE);
< 	SETSOP(NONQOP, 0, RAMRD);
< 	FTOYANDQ(FF, OLDQ, REGWRD);
< 	DOTOOUTREG;
< 	BPCCMD(LOADFA);
shstartside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
shtraploop.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
75a76
> #ifndef NOZPOLY
76a78
> #endif
229a232
> #ifndef NOZPOLY
230a234
> #endif
340a345
> #ifndef NOZPOLY
341a347
> #endif
startside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
swap.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
traploop.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zfillline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zfilltrap.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zfinishside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
3a4
> /*	subroutine DIVIDE_DELTA  used externally
40a42,43
> #ifndef NOZPOLY
> 
350a354
> #endif
406a411
> #ifndef NOZPOLY
708a714,715
> 
> #endif
zgetfrstsds.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zshadeline.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zshadetrap.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
zstartside.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
ztraploop.c
++++++++++++++++++++++++++++++++++++++++++++++++++++++
