'\"macro stdmacro
.TH LEX 1
.SH NAME
lex \- generate programs for simple lexical tasks
.SH SYNOPSIS
.B lex
[
.B \-rctvn
] [ file ] ...
.SH DESCRIPTION
.I Lex\^
generates programs to be used in simple lexical analysis of text.
.PP
The input
.I files\^
(standard input default)
contain strings and expressions
to be searched for, and C text to be executed when
strings are found.
.PP
A file
.B lex.yy.c
is generated which, when loaded
with the library, copies the input to the output
except when a string specified in the file is found; then
the corresponding program text is executed.
The actual string matched is left in
.IR yytext ,
an external character array.
Matching is done in order of the strings in the file.
The strings
may contain square brackets to indicate character classes,
as in
.B [abx\-z]
to indicate
.BR a , " b" , " x" ,
.BR y ", and " z ;
and the operators
.BR \(** ", " + ", and " ?
mean respectively
any non-negative number of, any positive number of, and either
zero or one occurrences of, the previous character or character class.
The character
.B .
is the class of all
.SM ASCII
characters except new-line.
Parentheses for grouping and vertical bar for alternation are
also supported.
The notation
.IR r\| { d , e\| }
in a rule indicates between
.I d\^
and
.I e\^
instances of regular expression
.IR r .
It has higher precedence than \^|\|,
but lower than \(**, ?, +,
and concatenation.
The character ^
at the beginning of an expression
permits a
successful match only immediately after a new-line, and the 
character $
at the end of an expression requires a trailing new-line.
The character /
in an expression indicates trailing context;
only the part of the expression up to the slash
is returned in
.IR yytext ,
but the remainder of the expression must follow in the input stream.
An operator character may be used as an ordinary symbol
if it is within " symbols or preceded by \e .
Thus
.RB [ a\-zA\-Z ]+
matches a string of letters.
.PP
Three subroutines defined as macros are expected:
.B input()
to read a character;
.BI unput( c\| )
to replace a character read; and
.BI output( c\| )
to place
an output character.
They are defined in terms
of the standard streams,
but you can override them.
The program generated is named
.BR yylex() ,
and the library contains a
.B main()
which calls it.
The action
.SM REJECT
on the right side of the rule causes this
match to be rejected and the next suitable match executed;
the function
.B yymore()
accumulates additional characters
into the same
.IR yytext ;
and the function
.BI yyless( p\| )
pushes
back the portion of the string matched beginning at
.IR p ,
which
should be between
.I yytext\^
and
.IR yytext + yyleng .
The macros
.I input\^
and
.I output\^
use files
.B yyin
and
.B yyout
to read from and write to,
defaulted to
.B stdin
and
.BR stdout ,
respectively.
.PP
Any line beginning with a blank is assumed
to contain only C text and is copied;
if it precedes %% ,
it is copied into the external definition area of the
.B lex.yy.c
file.
All rules should follow a %% ,
as in
.SM YACC\*S.
Lines preceding %%
which begin with a non-blank character define
the string on the left to be the remainder of
the line; it can be called out later by 
surrounding it with {} .
Note that curly brackets do not imply parentheses;
only string substitution is done.
.PP
The external names generated by
.I lex\^
all begin with the prefix
.BR yy " or " YY .
.PP
The flags must appear before any files.
The flag
.B \-r
indicates
.SM RATFOR
actions,
.B \-c
indicates C actions and is the default,
.B \-t
causes the
.B lex.yy.c
program to be written instead to standard output,
.B \-v
provides a one-line summary of statistics of the machine generated,
.B \-n
will not print out the
.BR \- " summary."
Multiple files are treated as a single file.
If no files are specified,
standard input is used.
.PP
Certain table sizes for the resulting finite state machine
can be set in the definitions section:
.RS .3i
.TP "\w'%\f3n\ \f2n\f1\ \ \ 'u"
\&%\f3p\ \f2n\f1
number of positions is
.I n\^
(default 2000)
.PD 0
.TP
\&%\f3n\ \f2n\f1
number of states is
.I n\^
(500)
.TP
\&%\f3t\ \f2n\f1
number of parse tree nodes is
.I n\^
(1000)
.TP
\&%\f3a\ \f2n\f1
number of transitions is
.I n\^
(3000)
.RE
.PD
.PP
The use of one or more of the above automatically implies the
.B \-v
option,
unless the
.B \-n
option is used.
.SH EXAMPLE
.RS .3i
.ta \w'[a\-z]+ \| 'u +\w'printf("'u +\w'switch\ 'u
.nf
D	[0\-9]
%%
if	printf("\s-1IF\s+1 statement\\n");
[a\-z]+	printf("tag, value %s\\n",yytext);
0{D}+	printf("octal number %s\\n",yytext);
{D}+	printf("decimal number %s\\n",yytext);
"++"	printf("unary op\\n");
"+"	printf("binary op\\n");
"/\(**"	{	loop:
		while (input() != '\(**');
		switch (input()) {
			case '/': break;
			case '\(**': unput('\(**');
			default: go to loop;
		}
	}
.fi
.RE
.DT
.SH SEE ALSO
yacc(1).
.br
.I "\s-1LEX\s+1\-Lexical Analyzer Generator\^"
by M. E. Lesk and E. Schmidt.
.SH BUGS
The \f3\-r\fP option is not yet fully operational.
.\"	@(#)lex.1	5.1 of 11/17/83
