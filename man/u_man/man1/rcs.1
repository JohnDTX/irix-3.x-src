'\"macro stdmacro
.TH RCS 1
.SH NAME
rcs \- change RCS file attributes
.SH SYNOPSIS
.B rcs
[ options ]
file ... 
.SH DESCRIPTION
.I rcs
creates new RCS files or changes attributes of existing ones.
An RCS file contains multiple revisions of text,
an access list, a change log, 
descriptive text,
and some control attributes.
For \f2rcs\f1 to work, the caller's login name must be on the access list,
except if the access list is empty, the caller is the owner of the file
or the superuser, or
the \f3-i\f1 option is present. 
.PP
Files ending in `,v' are RCS files, all others are working files. If
a working file is given, \f2rcs\f1 tries to find the corresponding
RCS file first in directory ./RCS and then in the current directory,
as explained in \f2co\f1 (1).
.TP 11
.B \-i
creates and initializes a new RCS file, but does not deposit any revision.
If the RCS file has no path prefix, \f2rcs\f1 tries to place it
first into the subdirectory ./RCS, and then into the current directory.
If the RCS file
already exists, an error message is printed.
.TP
.BI \-a "logins"
appends the login names appearing in the comma-separated list \f2logins\f1
to the access list of the RCS file.
.TP
.BI \-A "oldfile"
appends the access list of \f2oldfile\f1 to the access list of the RCS file. 
.TP
.B \-e\f1[\f2logins\f1]
erases the login names appearing in the comma-separated list \f2logins\f1
from the access list of the RCS file.
If \f2logins\f1 is omitted, the entire access list is erased.
.TP
.BI \-c "string"
sets the comment leader to \f2string\f1. The comment leader
is printed before every log message line generated by the keyword 
$\&Log$  during checkout (see \f2co\f1). This is useful for programming 
languages without multi-line comments. During \f2rcs -i\f1 or initial 
\f2ci\f1, the comment leader is guessed from the suffix of the working file. 
.TP
.B \-l\f1[\f2rev\f1]
locks the revision with number \f2rev\f1.
If a branch is given, the latest revision on that branch is locked.
If \f2rev\f1 is omitted, the latest revision on the trunk is locked.
Locking prevents overlapping changes.
A lock is removed with \f2ci\f1 or \f2rcs -u\f1 (see below).
.TP
.B \-u\f1[\f2rev\f1]
unlocks the revision with number \f2rev\f1.
If a branch is given, the latest revision on that branch is unlocked.
If \f2rev\f1 is omitted, the latest lock held by the caller is removed.
Normally, only the locker of a revision may unlock it.
Somebody else unlocking a revision breaks the lock. 
This causes a mail message to be sent to the original locker.
The message contains a commentary solicited from the breaker.
The commentary is terminated with a line containing a single `.' or
control-D.
.TP
.B \-L
sets locking to \f2strict\f1. Strict locking means that the owner
of an RCS file is not exempt from locking for checkin.
This option should be used for files that are shared.
.TP
.B \-U
sets locking to non-strict. Non-strict locking means that the owner of
a file need not lock a revision for checkin. 
This option should NOT be used for files that are shared.
The default (\f3-L\f1 or \f3-U\f1) is determined by your system administrator.
.TP
.B \-n\f2name\f1[:\f2rev\f1]
associates the symbolic name \f2name\f1 with the branch or
revision \f2rev\f1. 
\f2Rcs\f1 prints an error message if \f2name\f1 is already associated with
another number.
If \f2rev\f1 is omitted, the symbolic name is deleted.
.TP
.B \-N\f2name\f1[:\f2rev\f1]
same as \f3-n\f1, except that it overrides a previous assignment of 
\f2name\f1.
.TP
.BI \-o "range"
deletes (``outdates'') the revisions given by \f2range\f1.
A range consisting of a single revision number means that revision.
A range consisting of a branch number means the latest revision on that
branch.
A range of the form \f2rev1\-rev2\f1 means 
revisions \f2rev1\f1 to \f2rev2\f1 on the same branch, 
\f2\-rev\f1 means from the beginning of the branch containing
\f2rev\f1 up to and including \f2rev\f1, and \f2rev\-\f1 means
from revision \f2rev\f1 to the end of the branch containing \f2rev\f1.
None of the outdated revisions may have branches or locks.
.TP
.B \-q
quiet mode; diagnostics are not printed.
.TP
.B \-s\f2state\f1[:\f2rev\f1]
sets the state attribute of the revision \f2rev\f1 to \f2state\f1. 
If \f2rev\f1 is omitted, the latest revision on the trunk is assumed.
If \f2rev\f1 is a branch number, the latest revision on that branch is
assumed.
Any identifier is acceptable for \f2state\f1.
A useful set of states
is \f2Exp\f1 (for experimental), \f2Stab\f1 (for stable), and \f2Rel\f1 (for
released).
By default, \f2ci\f1 sets the state of a revision to \f2Exp\f1.
.TP
.B \-t\f1[\f2txtfile\f1]
writes descriptive text into the RCS file (deletes the existing text).
If \f2txtfile\f1 is omitted, 
\f2rcs\f1 prompts the user for text supplied from the std. input,
terminated with a line containing a single `.' or control-D.
Otherwise, the descriptive text is copied from the file \f2txtfile\f1.
If the \f3-i\f1 option is present, descriptive text is requested
even if \f3-t\f1 is not given.
The prompt is suppressed if the std. input is not a terminal.
.SH DIAGNOSTICS
The RCS file name and the revisions outdated are written to
the diagnostic output.
The exit status always refers to the last RCS file operated upon,
and is 0 if the operation was successful, 1 otherwise.
.SH FILES
The caller of the command
must have read/write permission for the directory containing
the RCS file and read permission for the RCS file itself.
.I Rcs
creates a semaphore file in the same directory as the RCS
file to prevent simultaneous update.
For changes, \f2rcs\f1 always creates a new file. On successful completion,
\f2rcs\f1 deletes the old one and renames the new one.
This strategy makes links to RCS files useless.
.SH IDENTIFICATION
Author: Walter F. Tichy,
.br
Purdue University, West Lafayette, IN, 47907.
.br
Copyright \(co 1982 by Walter F. Tichy.
.SH SEE ALSO
co (1), ci (1), ident(1), rcsdiff (1), rcsintro (1), rcsmerge (1), rlog (1), rcsfile (4).
.sp 0
Walter F. Tichy, ``Design, Implementation, and Evaluation of a Revision Control
System,'' in \f2Proceedings of the 6th International Conference on Software
Engineering\f1, IEEE, Tokyo, Sept. 1982.




