(*****************************************************************************)
(*                                                                           *)
(*                             File: CODE.6.TEXT                             *)
(*                                                                           *)
(*           (C) Copyright 1980, 1985 Silicon Valley Software, Inc.          *)
(*                                                                           *)
(*                            All rights reserved.               04-Oct-85   *)
(*                                                                           *)
(*****************************************************************************)


  function fmtref(ffmtno: integer): integer;
    var lfmtrec: pfmtrec; Done: Boolean;
  begin
  lfmtrec := fmtlist; Done := FALSE;
  while (lfmtrec <> nil) and (not Done) do begin
        if lfmtrec^.fmtno = ffmtno
        then begin
             fmtref := lfmtrec^.fmtilabno; Done := TRUE;
             end
        else lfmtrec := lfmtrec^.next;
        end;
  if lfmtrec = nil then error(2010);
  end; {fmtref}
  
  procedure cassign;
    var lsize,lop,mop,ltype,rtype,rsize: integer;
        ImmFlag,DregFlag,ExprFlag,UnFlag,Done: Boolean; lcattr,tcattr: cattr;
        d,d2,a,exprreg: pregrec; lname: alfa8; immval: longint;
  begin
  lop := nextbyte; ltype := nextbyte;
  rtype := ltype mod 16; ltype := ltype div 16;
  lsize := csizes[ltype]; rsize := csizes[rtype];
  if lop = 16 { L = E, Packed }
  then asspckfld(nextbyte,TRUE)
  else
  if lop = 0 { L = E }
  then begin
       expression(nextbyte); lcattr := gcattr;
       expression(nextbyte); tcattr := gcattr;
       if (lcattr.ckind = EXPR) and (gcattr.ckind <> EXPR)
       then begin dupref(lcattr,lsize); gcattr := lcattr; end
       else begin dupref(tcattr,lsize); gcattr := tcattr; end;
       store(tcattr,lcattr,lsize);
       end
  else begin
       expression(nextbyte); lcattr := gcattr;
       { 1. LTYPE is the type of the l-value     }
       { 2. RTYPE is the type of the expression  }
       { 3. RTYPE is at least as big as LTYPE    }
       { 4. If LTYPE is FLT4/8 then RTYPE is too }
       case rtype of
         0, { INT1 }
         1, { INT2 }
         2: { INT4 }
            begin
            case lop of
              1, { *= }
              2, { /= }
              3, { %= }
             12, { /u= }
             13: { %u= }
                 begin
                 if lop >= 12
                 then begin UnFlag := TRUE; lop := lop - 10; end
                 else UnFlag := FALSE;
                 if lcattr.ckind = EXPR
                 then begin
                      ExprFlag := TRUE; exprreg := lcattr.exreg;
                      end
                 else begin
                      ExprFlag := FALSE;
                      a := loadaddress(lcattr);
                      lcattr.ckind := ADDR; lcattr.adreg := a;
                      lcattr.aoffset := 0;
                      end;
                 if rsize <= WORD
                 then begin
                      dupref(lcattr,lsize); tcattr := lcattr;
                      d := loadd(lcattr,lsize);
                      isolate(d); lcattr.exreg := d; erase(d);
                      if lsize = BYTE
                      then if lop >= 2
                           then if UnFlag
                                then begin
                                     { ANDI.W D } genr(576,d); gen(255);
                                     end
                                else { EXT.W D } genr(18560,d);
                      expression(nextbyte); forgetcattr(tcattr,lsize);
                      if (rsize = BYTE) and (gcattr.ckind <> CNST)
                      then begin
                           d2 := loadd(gcattr,rsize); isolate(d2);
                           gcattr.exreg := d2; erase(d2);
                           if lop >= 2
                           then if UnFlag
                                then begin
                                     { ANDI.W D2 } genr(576,d2); gen(255);
                                     end
                                else { EXT.W D2 } genr(18560,d2);
                           end;
                      load(d); lock(d);
                      if lop = 1
                      then mop := -15936 { MULS <ea>,D }
                      else if UnFlag
                           then begin
                                {ANDI.L #$ffff,d} genr(640,d); gen(0); gen(-1);
                                mop := -32576; { DIVU <ea>,D }
                                end
                           else begin
                                { EXT.L D } genr(18624,d);
                                mop := -32320; { DIVS <ea>,D }
                                end;
                      geneffaddr(mop + d^.regno*512,gcattr,WORD,FALSE,0);
                      unlock(d);
                      if lop = 3 then genr(18496,D); { SWAP D }
                      dupref(lcattr,lsize); gcattr := lcattr;
                      store(lcattr,tcattr,lsize);
                      end
                 else begin
                      if lsize = LONG
                      then if ExprFlag
                           then { MOVE.L R,-(SP) }
                                gen(12032 + ord(exprreg^.regno))
                           else { MOVE.L (A),-(SP) } genr(12048,a)
                      else begin
                           d := getreg(D0,D7);
                           if UnFlag then { CLR.L D } genr(17024,d);
                           if lsize = BYTE
                           then begin
                                if ExprFlag
                                then { MOVE.B R,D } genrr(4096,d,exprreg)
                                else { MOVE.B (A),D } genrr(4112,d,a);
                                if not UnFlag then { EXT.W D } genr(18560,d);
                                end
                           else if ExprFlag
                                then { MOVE.W R,D }
                                     genr0(12288 + ord(exprreg^.regno),d)
                                else { MOVE.W (A),D } genrr(12304,d,a);
                           if not UnFlag then { EXT.L D } genr(18624,d);
                           { MOVE.L D,-(SP) } genr(12032,d);
                           freereg(d);
                           end;
                      expression(nextbyte); pushvalue(gcattr,LONG);
                      forgetcattr(lcattr,LONG);
                      if FPHardware and MAX_FLAG
                      then begin
                           if lop = 1
                           then maxcmd(M_IMUL4,4)
                           else if lop = 2
                                then if UnFlag
                                     then maxcmd(M_IDIV4,4)
                                     else maxcmd(M_UDIV4,4)
                                else if UnFlag
                                     then maxcmd(M_IMOD4,4)
                                     else maxcmd(M_UMOD4,4);
                           end
                      else begin
                           if lop = 1
                           then lname := '%I_MUL4 '
                           else begin
                                if lop = 2
                                then lname := '%I_DIV4 '
                                else lname := '%I_MOD4 ';
                                if UnFlag then lname[2] := 'U';
                                end;
                           genjsra(lname);
                           end;
                      if lsize = LONG
                      then begin
                           if ExprFlag
                           then begin
                                erase(exprreg);
                                if exprreg^.regno <= D7
                                then { MOVE.L (SP)+,D } genr0(8223,exprreg)
                                else { MOVE.L (SP)+,A } genr0(8287,exprreg);
                                end
                           else { MOVE.L (SP)+,(A) } genr0(8351,a);
                           gcattr := lcattr;
                           end
                      else begin
                           d := getreg(D0,D7);
                           { MOVE.L (SP)+,D } genr(8223,d);
                           if ExprFlag
                           then begin
                                if lsize = BYTE
                                then lop := 4096 { MOVE.B }
                                else lop := 12288; { MOVE.W }
                                if exprreg^.regno >= A0 then lop := lop + 64;
                                genrr(lop,exprreg,d); erase(exprreg);
                                end
                           else begin
                                if lsize = BYTE
                                then { MOVE.B D,(A) } genrr(4224,a,d)
                                else { MOVE.W D,(A) } genrr(12416,a,d);
                                freereg(a);
                                end;
                           gcattr.ckind := EXPR; gcattr.exreg := d;
                           end;
                      end;
                 if IsDReg(gcattr) and (ccodereg = SP)
                 then ccodereg := gcattr.exreg^.regno;
                 end;
              6, { >>= }
              7, { >u>= }
              8: { <<= }
                 begin
                 if lop = 6
                 then lop := -8192 { ASR.B #x,D }
                 else if lop = 7
                      then lop := -8184 { LSR.B #x,D }
                      else lop := -7928; { LSL.B #x,D }
                 if lsize = WORD
                 then lop := lop + 64
                 else if lsize = LONG
                      then lop := lop + 128;
                 if lcattr.ckind <> EXPR
                 then begin
                      a := loadaddress(lcattr);
                      lcattr.ckind := ADDR; lcattr.adreg := a;
                      lcattr.aoffset := 0;
                      end;
                 dupref(lcattr,lsize); tcattr := lcattr;
                 d := loadd(lcattr,lsize);
                 isolate(d); lcattr.exreg := d; erase(d);
                 expression(nextbyte);
                 if (gcattr.ckind = CNST) and
                    (gcattr.cvalu.lvalu > 0) and (gcattr.cvalu.lvalu <= 8)
                 then gennr(lop,gcattr.cvalu.lvalu,d)
                 else begin
                      load(d); lock(d);
                      d2 := loadd(gcattr,rsize);
                      genrr(lop + 32,d2,d);
                      unlock(d); freereg(d2);
                      end;
                 dupref(lcattr,lsize); gcattr := lcattr;
                 store(lcattr,tcattr,lsize);
                 if IsDReg(gcattr) and (ccodereg = SP)
                 then ccodereg := gcattr.exreg^.regno;
                 end;
              4, { += }
              5, { -= }
              9, { &= }
             10, { ^= }
             11: { |= }
                 begin
                 Done := FALSE;
                 expression(nextbyte); DregFlag := FALSE; ExprFlag := FALSE;
                 if gcattr.ckind = CNST
                 then begin
                      Done := TRUE; ImmFlag := TRUE;
                      immval := gcattr.cvalu.lvalu;
                      if lop = 4
                      then if (immval > 0) and (immval <= 8)
                           then begin { ADDQ }
                                lop := 20480 + (immval mod 8)*512;
                                ImmFlag := FALSE;
                                end
                           else if IsAReg(lcattr)
                                then Done := FALSE
                                else lop := 1536 { ADDI.B #-,<ea> }
                      else if lop = 5
                           then if (immval > 0) and (immval <= 8)
                                then begin { SUBQ }
                                     lop := 20736 + (immval mod 8)*512;
                                     ImmFlag := FALSE;
                                     end
                                else if IsAReg(lcattr)
                                     then Done := FALSE
                                     else lop := 1024 { SUBI.B #-,<ea> }
                           else if lop = 9
                                then lop := 512 { ANDI.B #-,<ea> }
                                else if lop = 10
                                     then lop := 2560 { EORI.B #-,<ea> }
                                     else lop := 0;   { ORI.B  #-,<ea> }
                      end;
                 if not Done
                 then begin
                      ImmFlag := FALSE; immval := 0; DregFlag := TRUE;
                      d := loadd(gcattr,rsize); lock(d);
                      if lop = 4
                      then lop := -12032 { ADD.B D,<ea> }
                      else if lop = 5
                           then lop := -28416 { SUB.B D,<ea> }
                           else if lop = 9
                                then lop := -16128 { AND.B D,<ea> }
                                else if lop = 10
                                     then lop := -20224 { EOR.B D,<ea> }
                                     else lop := -32512; { OR.B D,<ea> }
                      if (lcattr.ckind = EXPR) and (lop <> -20224)
                      then ExprFlag := TRUE
                      else lop := lop + d^.regno*512;
                      end;
                 if lsize = WORD
                 then lop := lop + 64
                 else if lsize = LONG
                      then lop := lop + 128;
                 forgetcattr(lcattr,lsize);
                 if ExprFlag
                 then begin
                      if lcattr.exreg^.regno > D7
                      then begin
                           if d^.regno = 0 then mop := 512 else mop := 0;
                           { EXG D,A } genr(-15992 + mop,lcattr.exreg);
                           genr(lop - 256 + mop,d);
                           { EXG D,A } genr(-15992 + mop,lcattr.exreg);
                           end
                      else genrr(lop - 256,lcattr.exreg,d);
                      gcattr := lcattr; erase(lcattr.exreg);
                      end
                 else begin
                      dupref(lcattr,lsize); gcattr := lcattr;
                      geneffaddr(lop,lcattr,lsize,ImmFlag,immval);
                      end;
                 if DregFlag then begin unlock(d); freereg(d); end;
                 if IsDReg(gcattr) and (ccodereg = SP)
                 then ccodereg := gcattr.exreg^.regno;
                 end;
            end; {case}
            end;
         3, { FLT4 }
         4: { FLT8 }
            begin
            if ltype = 4 {FLT8} then incoffset(lcattr,8);
            if lcattr.ckind = EXPR
            then begin ExprFlag := TRUE; exprreg := lcattr.exreg; end
            else begin
                 ExprFlag := FALSE;
                 a := loadaddress(lcattr);
                 end;
            if ltype <= 2 {INT4}
            then begin
                 if ltype = 2 {INT4}
                 then if ExprFlag
                      then { MOVE.L R,-(SP) } gen(12032 + ord(exprreg^.regno))
                      else { MOVE.L (A),-(SP) } genr(12048,a)
                 else begin
                      d := getreg(D0,D7);
                      if ltype = 0 {INT1}
                      then begin
                           if ExprFlag
                           then { MOVE.B R,D } genrr(4096,d,exprreg)
                           else { MOVE.B (A),D } genrr(4112,d,a);
                           { EXT.W D } genr(18560,d);
                           end
                      else {INT2} if ExprFlag
                           then { MOVE.W R,D }
                                genr0(12288 + ord(exprreg^.regno),d)
                           else { MOVE.W (A),D } genrr(12304,d,a);
                      { EXT.L D } genr(18624,d);
                      { MOVE.L D,-(SP) } genr(12032,d);
                      freereg(d);
                      end;
                 if rtype = 3 {FLT4}
                 then lname := '%I_2_F  '
                 else lname := '%I_2_D  ';
                 genjsra(lname);
                 end
            else if ltype = 3 {FLT4}
                 then if ExprFlag
                      then { MOVE.L R,-(SP) } gen(12032 + ord(exprreg^.regno))
                      else { MOVE.L (A),-(SP) } genr(12048,a)
                 else begin {FLT8}
                      isolate(a);
                      { MOVE.L -(A),-(SP) } genr(12064,a);
                      { MOVE.L -(A),-(SP) } genr(12064,a);
                      incrv(a^.regno,-8);
                      end;
            expression(nextbyte); pushvalue(gcattr,rsize);
            case lop of
              1: lname := '%F_MUL  ';
              2,12: lname := '%F_DIV  ';
              4: lname := '%F_ADD  ';
              5: lname := '%F_SUB  ';
            end; {case}
            if rtype = 4 then lname[2] := 'D';
            genjsra(lname);
            if ExprFlag
            then begin gcattr.ckind := EXPR; gcattr.exreg := exprreg; end
            else begin
                 load(a);
                 gcattr.ckind := ADDR; gcattr.adreg := a; gcattr.aoffset := 0;
                 end;
            if ltype <= 2 {INT4}
            then begin
                 if rtype = 3 {FLT4}
                 then lname := '%F_2_I  '
                 else lname := '%D_2_I  ';
                 genjsra(lname);
                 if ltype = 2
                 then if ExprFlag
                      then if exprreg^.regno <= D7
                           then { MOVE.L (SP)+,D } genr0(8223,exprreg)
                           else { MOVE.L (SP)+,A } genr0(8287,exprreg)
                      else { MOVE.L (SP)+,(A) } genr0(8351,a)
                 else begin
                      d := getreg(D0,D7);
                      { MOVE.L (SP)+,D } genr0(8223,d);
                      if ExprFlag
                      then begin
                           if ltype = 0 {INT1}
                           then lop := 4096 { MOVE.B }
                           else lop := 12288; { MOVE.W }
                           if exprreg^.regno >= A0 then lop := lop + 64;
                           genrr(lop,exprreg,d); erase(exprreg);
                           end
                      else begin
                           if ltype = 0 {INT1}
                           then { MOVE.B D,(A) } genrr(4224,a,d)
                           else { MOVE.W D,(A) } genrr(12416,a,d);
                           freereg(a);
                           end;
                      gcattr.ckind := EXPR; gcattr.exreg := d;
                      end;
                 end
            else if ltype = 3 {FLT4}
                 then if ExprFlag
                      then begin
                           if exprreg^.regno <= D7
                           then { MOVE.L (SP)+,D } genr0(8223,exprreg)
                           else { MOVE.L (SP)+,A } genr0(8287,exprreg);
                           erase(exprreg);
                           end
                      else { MOVE.L (SP)+,(A) } genr0(8351,a)
                 else begin {FLT8}
                      { MOVE.L (SP)+,(A)+ } genr0(8415,a);
                      { MOVE.L (SP)+,(A)+ } genr0(8415,a);
                      gcattr.aoffset := -8; incrv(a^.regno,8);
                      end;
            end;
       end; {case}
       end;
  end; {cassign}
  
  procedure expr3(fop: integer);
    var lopsize,lsize,setsize,llabel,lop,mop,ltype,lincr,i: integer;
        OnStack,LeftStack,RightStack,ExprFlag: Boolean;
        lcattr: cattr; lcc: condition; rsize,mlabel: integer;
        d,d2,td,a,exprreg: pregrec; l: longint;
  begin
  case fop of
  157: { FMTREF }
       begin
       a := getreg(A0,AMAX);
       { LEA $+xxx,A } genr0(16890,a); pcrefblk(fmtref(nextword));
       gcattr.ckind := ADDR; gcattr.adreg := a; gcattr.aoffset := 0;
       end;
  163: { IN }
       begin
       setsize := nextbyte; expression(nextbyte);
       d := loadd(gcattr,WORD); llabel := newlabel;
       if ccodereg <> d^.regno then { TST.W D } genr(19008,d);
       genjump(_BMI,llabel);
       setexpression(nextbyte,OnStack);
       if OnStack
       then begin
            load(d); lock(d); d2 := getreg(D0,D7); freereg(d2); unlock(d);
            { MOVE.W (SP),D2 } genr0(12311,d2);
            { LSL.W #3,D2 } genr(-6328,d2);
            { SUBQ.W #1,D2 } genr(21312,d2);
            { CMP.W  D2,D } genrr(-20416,d,d2);
            end
       else begin
            { CMP.W #xx,D } genr0(-20356,d); gen(setsize*8 - 1);
            end;
       genjump(_BGT,llabel);
       if OnStack
       then begin
            load(d); isolate(d); lock(d); erase(d);
            d2 := getreg(D0,D7); freereg(d2); unlock(d);
            { MOVE.W D,D2 } genrr(12288,d2,d);
            
            { This code is chip independent: }
            
            { ANDI.W #7,D } genr(576,d); gen(7);
            { LSR.W #3,D2 } genr(-6584,d2);
            { NEG.W D2 } genr(17472,d2);
            { ADD.W (SP),D2 } genr0(-12201,d2);
            { MOVE.B 1(SP,D2.W),D2 } genr0(4151,d2); gen(d2^.regno*4096 + 1);
            { BTST D,D2 } genrr(256,d,d2);
            end
       else begin
            makevalid(gcattr); lockcattr(gcattr);
            load(d); isolate(d); erase(d); lock(d); unlockcattr(gcattr);
            if gcattr.ckind = EXPR
            then begin
                 { BTST D,exreg } genrr(256,d,gcattr.exreg);
                 freereg(gcattr.exreg); erase(gcattr.exreg);
                 end
            else begin
                 if gcattr.ckind <> CNST then incoffset(gcattr,setsize);
                 a := loadaddress(gcattr); lock(a);
                 d2 := getreg(D0,D7); freereg(d2);
                 { MOVE.W D,D2 } genrr(12288,d2,d);
                 
                 { This code is chip independent: }
                 
                 { ANDI.W #7,D } genr(576,d); gen(7);
                 { LSR.W #3,D2 } genr(-6584,d2);
                 { NEG.W D2 } genr(17472,d2);
                 { MOVE.B -1(A,D2.W),D2 } genrr(4144,d2,a);
                                          gen(d2^.regno*4096 + 255);
                 { BTST D,D2 } genrr(256,d,d2);
                 unlock(a); freereg(a);
                 end;
            unlock(d);
            end;
       { EORI.B #4,SP } gen(2620); gen(4);
       defilabel(llabel); freereg(d);
       if OnStack then { ADDA.W (SP)+,SP } gen(-8481);
       gcattr.ckind := COND; gcattr.cc := EQ;
       end;
  164, { SETLE }
  165, { SETGE }
  166, { SETEQ }
  167: { SETNE }
       begin
       setsize := nextbyte; setexpression(nextbyte,LeftStack);
       lcattr := gcattr; setexpression(nextbyte,RightStack);
       if (setsize > 4) or LeftStack or RightStack
       then begin
            if not LeftStack then pushset(lcattr,setsize,TRUE);
            if not RightStack then pushset(gcattr,setsize,TRUE);
            gcattr.ckind := EXPR; gcattr.exreg := getreg(D0,D0);
            case fop of
                 164: if RightStack and not LeftStack
                      then genjsra('%_SETGE ')
                      else genjsra('%_SETLE ');
                 165: if RightStack and not LeftStack
                      then genjsra('%_SETLE ')
                      else genjsra('%_SETGE ');
                 166: genjsra('%_SETEQ ');
                 167: genjsra('%_SETNE ');
            end; {case}
            end
       else begin
            if setsize = 1
            then begin lopsize := 0; lsize := BYTE; end
            else if setsize = 2
                 then begin lopsize := 64; lsize := WORD; end
                 else begin lopsize := 128; lsize := LONG; end;
            makevalid(gcattr); lockcattr(gcattr); makevalid(lcattr);
            d := loadd(lcattr,lsize); isolate(d); lock(d); unlockcattr(gcattr);
            d2 := loadd(gcattr,lsize); isolate(d2); unlock(d);
            erase(d); erase(d2);
            if fop = 165 { >= }
            then begin td := d; d := d2; d2 := td; end;
            if fop <= 165
            then begin
                 { NOT D2 } genr(17920 + lopsize,d2);
                 { AND D2,D } genrr(-16384 + lopsize,d,d2);
                 end
            else { CMP D,D2 } genrr(-20480 + lopsize,d,d2);
            gcattr.ckind := COND;
            if fop = 167 { <> }
            then gcattr.cc := NE
            else gcattr.cc := EQ;
            freereg(d); freereg(d2);
            end;
       end;
  176, { UFCALL }
  177: { UPCALL }
       begin
       i := nextword;
       with userprocs[i div 32]^[i mod 32]^ do
            globref(procname,nextblk,pc - blkpc + 2);
       a := getreg(A0,AMAX);
       if SHORTCALLS
       then begin
            { LEA $+xxx } genr0(16890,a); gen(0);
            end
       else begin
            { LEA xxx.L } genr0(16889,a); gen2(0);
            end;
       gcattr.ckind := ADDR; gcattr.adreg := a; gcattr.aoffset := 0;
       end;
  190: { PARMLST} gencall;
  204: { ILABREF }
       begin
       a := getreg(A0,AMAX);
       { LEA $+xxx,A } genr0(16890,a); pcrefblk(nextword);
       gcattr.ckind := ADDR; gcattr.adreg := a; gcattr.aoffset := 0;
       end;
  208: { Complex Binary Ops }
       begin
       case nextbyte of
         0: { COMPLEX }
            begin
            { Imag } expression(nextbyte); pushvalue(gcattr,LONG);
            { Real } expression(nextbyte); pushvalue(gcattr,LONG);
            gcattr.ckind := STCK;
            end;
         1: push88call('%C_ADD  ',TRUE,8);
         2: push88call('%C_SUB  ',TRUE,8);
         3: push88call('%C_MUL  ',TRUE,8);
         4: push88call('%C_DIV  ',TRUE,8);
       end; {case}
       end;
  209: { Complex Compares }
       begin
       lop := nextbyte;
       push88call('%C_CMP  ',FALSE,0);
       gcattr.ckind := COND;
       if lop = 0 then gcattr.cc := EQ else gcattr.cc := NE;
       end;
  210: { Complex Unary Ops: RPART, IPART, CNEG. }
       begin
       lop := nextbyte;
       if lop = 2
       then push8call('%C_NEG  ',TRUE,8)
       else begin
            expression(nextbyte);
            if (gcattr.ckind = VARB) or
               (gcattr.ckind = ADDR) or
               (gcattr.ckind = INDX) or
               (gcattr.ckind = FDAT)
            then begin
                 if lop <> 0
                 then incoffset(gcattr,4);
                 end
            else begin
                 pushvalue(gcattr,QUAD);
                 if lop = 0
                 then { MOVE.L (SP)+,(SP) } gen(11935)
                 else { ADDQ.L #4,SP } gen(22671);
                 gcattr.ckind := STCK;
                 end;
            end;
       end;
  211: { DOD Extensions: }
       begin
       lop := nextbyte;
       if lop <> 0 then error(8382); { Only ISHFT done for now }
       expression(nextbyte); lcattr := gcattr; expression(nextbyte);
       d := loadd(lcattr,LONG); isolate(d); erase(d); lock(d);
       if gcattr.ckind = CNST
       then begin
            if gcattr.cvalu.lvalu <> 0
            then begin
                 if gcattr.cvalu.lvalu > 0
                 then lop := _LSL_L
                 else lop := _LSR_L;
                 i := abs(gcattr.cvalu.lvalu);
                 if i <= 31
                 then begin
                      while i > 8 do begin genr(lop,d); i := i - 8; end;
                      gennr(lop,i,d);
                      end;
                 end;
            end
       else begin
            d2 := loadd(gcattr,LONG); isol(d2,LONG,TRUE);
            llabel := newlabel; mlabel := newlabel;
            if ccodereg <> d2^.regno then testd(d2,LONG);
            genjump(_BLT,llabel);
            genrr(_LSL_L+$20,d2,d);
            genjump(_BRA,mlabel);
            defilabel(llabel);
            genr(_NEG_L,d2);
            genrr(_LSR_L+$20,d2,d);
            defilabel(mlabel);
            erase(d2); freereg(d2);
            end;
       unlock(d); gcattr.ckind := EXPR; gcattr.exreg := d;
       end;
  214: { FINDEX } genfindex;
  219: { FCHCMP }
       begin
       lop := nextbyte; pushfchaddr(nextbyte); pushfchaddr(nextbyte);
       genjsra('%FC_CMP '); gcattr.ckind := COND;
       { Unsigned bytes }
       case lop of
         0: gcattr.cc := LO;
         1: gcattr.cc := HI;
         2: gcattr.cc := LS;
         3: gcattr.cc := HS;
         4: gcattr.cc := EQ;
         5: gcattr.cc := NE;
       end; {case}
       end;
  224: { C-UNOPS }
       begin
       lop := nextbyte;
       case lop of
         0, {UINT12}
         1, {UINT14}
         2: {UINT24}
            begin
            expression(nextbyte);
            if lop <= 1 then lsize := BYTE else lsize := WORD;
            case gcattr.ckind of
              CNST: begin
                    if lop = 0
                    then d := loadint(gcattr.cvalu.lvalu,WORD)
                    else d := loadint(gcattr.cvalu.lvalu,LONG);
                    end;
              ADDR,
              VARB,
              FDAT,
              INDX: begin
                    d := loadint(0,LONG); lock(d); isolate(d); erase(d);
                    if lsize = BYTE then lop := 4096 else lop := 12288;
                    geneffaddr(lop+d^.regno*512,gcattr,lsize,FALSE,0);
                    unlock(d); ccodereg := d^.regno;
                    end;
              otherwise:
                    begin
                    d := loadd(gcattr,lsize); isolate(d); erase(d);
                    if lop = 0
                    then { ANDI.W #$ff,D } genr(576,d)
                    else begin { ANDI.L #$xxxx,D } genr(640,d); gen(0); end;
                    if lsize = BYTE then gen(255) else gen(-1);
                    ccodereg := d^.regno;
                    end;
            end; {case}
            gcattr.ckind := EXPR; gcattr.exreg := d;
            end;
       end; {case}
       end;
  225: { C-BINOPS }
       begin
       lop := nextbyte;
       case lop of
         0, {<<}
         1, {>> Signed}
         2: {>> Unsigned}
            begin
            if lop = 0
            then lop := -7800 { LSL.L #x,D }
            else if lop = 1
                 then lop := -8064 { ASR.L #x,D }
                 else lop := -8056;{ LSR.L #x,D }
            expression(nextbyte); d := loadd(gcattr,LONG);
            expression(nextbyte);
            if (gcattr.ckind = CNST) and (gcattr.cvalu.lvalu <= 8) and
               (gcattr.cvalu.lvalu >= 0)
            then begin
                 if gcattr.cvalu.lvalu <> 0
                 then begin
                      load(d); isolate(d); gennr(lop,gcattr.cvalu.lvalu,d);
                      ccodereg := d^.regno;
                      end;
                 end
            else begin
                 load(d); isolate(d); lock(d);
                 d2 := loadd(gcattr,LONG); unlock(d);
                 { SHIFT.L D2,D } genrr(lop + 32,d2,d);
                 freereg(d2); ccodereg := d^.regno;
                 end;
            gcattr.ckind := EXPR; gcattr.exreg := d; erase(d);
            end;
         3, {||}
         4: {&&}
            begin
            llabel := newlabel; expression(nextbyte); d := loadd(gcattr,BYTE);
            if lop = 3 then mop := _BNE else mop := _BEQ;
            genjump(mop,llabel); i := d^.regno; freereg(d);
            expression(nextbyte); d2 := loadd(gcattr,BYTE);
            if d2^.regno <> i
            then begin
                 d := getreg(i,i); freereg(d2);
                 { MOVE.B D2,D } genrr(4096,d,d2);
                 ccodereg := d^.regno; d2 := d; erase(d);
                 end;
            gcattr.ckind := EXPR; gcattr.exreg := d2;
            defilabel(llabel);
            end;
         8, { UDIV2 }
        10: { UMOD2 }
            begin
            numexpr(nextbyte,WORD); lcattr := gcattr; numexpr(nextbyte,WORD);
            make2valid(gcattr,lcattr);
            if (gcattr.ckind = STCK) and (lcattr.ckind = STCK)
            then begin
                 lockcattr(lcattr); d := loadd(gcattr,WORD);
                 unlockcattr(lcattr);
                 end;
            lockcattr(gcattr); d := loadd(lcattr,WORD); isolate(d);
            { ANDI.L } genr(640,d); gen(0); gen(-1);
            unlockcattr(gcattr); lock(d);
            geneffaddr(-32320 + d^.regno*512,gcattr,WORD,FALSE,0);
            unlock(d); ccodereg := d^.regno; erase(d);
            if fop = 72 then genr(18496,d); { SWAP }
            gcattr.ckind := EXPR; gcattr.exreg := d;
            end;
         9: { UDIV4 } if FPHardware and MAX_FLAG
                      then maxcmd(M_UDIV4,4)
                      else push44call('%U_DIV4 ',TRUE,4);
        11: { UMOD4 } if FPHardware and MAX_FLAG
                      then maxcmd(M_UMOD4,4)
                      else push44call('%U_MOD4 ',TRUE,4);
        16, {ULT1}
        17, {ULT2}
        18, {ULT4}
        19, {UGT1}
        20, {UGT2}
        21, {UGT4}
        22, {ULE1}
        23, {ULE2}
        24, {ULE4}
        25, {UGE1}
        26, {UGE2}
        27: {UGE4}
            begin
            lop := lop - 16;
            case lop mod 3 of
              0: lsize := BYTE;
              1: lsize := WORD;
              2: lsize := LONG;
            end; {case}
            case lop div 3 of
              0: lcc := LO;
              1: lcc := HI;
              2: lcc := LS;
              3: lcc := HS;
            end; {case}
            numexpr(nextbyte,lsize); lcattr := gcattr; numexpr(nextbyte,lsize);
            if GenCompare(lcattr,gcattr,lsize)
            then case lcc of
                  LO: lcc := HI;
                  HI: lcc := LO;
                  LS: lcc := HS;
                  HS: lcc := LS;
                 end; {case}
            gcattr.ckind := COND; gcattr.cc := lcc;
            end;
       end; {case}
       end;
  226: { C-UNOPS }
       begin
       lop := nextbyte; ltype := lop mod 16; lop := lop div 16;
       lsize := csizes[ltype];
       lincr := nextword; expression(nextbyte);
       case lop of
         0, { L++ }
         1, { L-- }
         2, { ++L }
         3: { --L }
            begin
            forgetcattr(gcattr,lsize);
            if odd(lop) then lincr := -lincr;
            {!!! What if it is a packed field? !!!}
            if lincr <> 0
            then begin
                 if ltype <= 2
                 then begin
                      lcattr := gcattr; dupref(gcattr,lsize);
                      if lop <= 1
                      then if IsAReg(gcattr)
                           then isolate(gcattr.exreg)
                           else begin
                                d := loadd(gcattr,lsize);
                                isolate(d); gcattr.exreg := d;
                                end;
                      if abs(lincr) <= 8
                      then begin
                           if lincr < 0
                           then lop := 20736 { SUBQ }
                           else lop := 20480;{ ADDQ }
                           lop := lop + sizebits[lsize];
                           geneffaddr(lop + (abs(lincr) mod 8)*512,lcattr,
                                      lsize,FALSE,0);
                           end
                      else begin
                           if IsAReg(lcattr)
                           then begin
                                { ADDA.W #x,A } genr0(-12036,lcattr.exreg);
                                                gen(lincr);
                                freereg(lcattr.exreg);
                                end
                           else begin
                                lop := 1536 + sizebits[lsize]; {ADDI}
                                geneffaddr(lop,lcattr,lsize,TRUE,lincr);
                                if IsDReg(gcattr)
                                then ccodereg := gcattr.exreg^.regno;
                                end;
                           end;
                      end
                 else begin {floating-point}
                      if ltype = 4 {double} then incoffset(gcattr,8);
                      if gcattr.ckind = EXPR
                      then begin ExprFlag := TRUE; exprreg := gcattr.exreg; end
                      else begin
                           ExprFlag := FALSE; a := loadaddress(gcattr);
                           end;
                      if ltype = 3 {float}
                      then begin
                           if odd(lop)
                           then l := $bf800000
                           else l := $3f800000;
                           if ExprFlag
                           then { MOVE.L D,-(SP) } genr(12032,exprreg)
                           else { MOVE.L (A),-(SP) } genr(12048,a);
                           if lop > 1
                           then begin
                                pushint(l,LONG);
                                genjsra('%F_ADD  ');
                                if ExprFlag
                                then { MOVE.L (SP),D } genr0(8215,exprreg)
                                else { MOVE.L (SP),(A) } genr0(8343,a);
                                end
                           else begin
                                { MOVE.L (SP),-(SP) } gen(12055);
                                pushint(l,LONG);
                                genjsra('%F_ADD  ');
                                if ExprFlag
                                then { MOVE.L (SP)+,D } genr0(8223,exprreg)
                                else { MOVE.L (SP)+,(A) } genr0(8351,a);
                                end;
                           end
                      else begin {double}
                           if odd(lop)
                           then l := $bff00000
                           else l := $3ff00000;
                           { MOVE.L -(A),-(SP) } genr(12064,a);
                           { MOVE.L -(A),-(SP) } genr(12064,a);
                           if lop > 1
                           then begin
                                pushint(0,LONG);
                                pushint(l,LONG);
                                genjsra('%D_ADD  ');
                                { MOVE.L (SP),(A)+ } genr0(8407,a);
                                { MOVE.L 4(SP),(A)+ } genr0(8431,a); gen(4);
                                end
                           else begin
                                { MOVE.L 4(SP),-(SP) } gen(12079); gen(4);
                                { MOVE.L 4(SP),-(SP) } gen(12079); gen(4);
                                pushint(0,LONG);
                                pushint(l,LONG);
                                genjsra('%D_ADD  ');
                                { MOVE.L (SP)+,(A)+ } genr0(8415,a);
                                { MOVE.L (SP)+,(A)+ } genr0(8415,a);
                                end;
                           end;
                      gcattr.ckind := STCK;
                      if not ExprFlag then freereg(a);
                      end;
                 end;
            end;
         4: { IGNORE }
            begin
            ignorexp(lsize);
            expression(nextbyte);
            end;
       otherwise: (***) writeln('BAD C OP  226:',lop:0);
       end; {case}
       end;
  227: { C-? }
       begin
       lop := nextbyte; mop := lop mod 16; lop := lop div 16;
       llabel := newlabel; mlabel := newlabel;
       saveallregs; clearscr; expression(nextbyte);
       if lop <= 3
       then begin
            lsize := csizes[lop];
            if gcattr.ckind = EXPR
            then if gcattr.exreg^.regno <= D7
                 then begin
                      if ccodereg <> gcattr.exreg^.regno
                      then begin
                           load(gcattr.exreg);
                           lop := 18944; {TST.B}
                           if lsize = WORD
                           then lop := lop + 64 {.W}
                           else if lsize = LONG
                                then lop := lop + 128; {.L}
                           genr(lop,gcattr.exreg);
                           end;
                      freereg(gcattr.exreg);
                      gcattr.ckind := COND; gcattr.cc := NE;
                      end;
            if gcattr.ckind <> COND
            then begin d := loadd(gcattr,lsize); freereg(d); end;
            end
       else begin
            pushvalue(gcattr,QUAD);
            { CLR.L -(SP) } gen(17063); gen(17063);
            genjsra('%D_CMP  ');
            end;
       if gcattr.ckind = COND
       then begin
            if odd(ord(gcattr.cc))
            then gcattr.cc := pred(gcattr.cc)
            else gcattr.cc := succ(gcattr.cc);
            lop := $60 + ord(gcattr.cc);
            end
       else lop := _BEQ;
       genjump(lop,llabel);
       rsize := csizes[mop];
       expression(nextbyte);
       if mop <= 2
       then begin d := loadd(gcattr,rsize); isolate(d); freereg(d); end
       else pushvalue(gcattr,rsize);
       genjump(_BRA,mlabel);
       defilabel(llabel);
       expression(nextbyte);
       if mop <= 2
       then begin
            d2 := loadd(gcattr,rsize);
            if d^.regno <> d2^.regno
            then begin
                 d := getreg(d^.regno,d^.regno);
                 { MOVE.L D2,D } genrr(8192,d,d2);
                 freereg(d2);
                 gcattr.ckind := EXPR; gcattr.exreg := d;
                 if rsize = LONG then ccodereg := d^.regno;
                 end;
            end
       else begin
            pushvalue(gcattr,rsize);
            gcattr.ckind := STCK;
            end;
       defilabel(mlabel);
       end;
  228: { CASSIGN } cassign;
  otherwise: writeln('OP ''',fop:0,''' not implemented in EXPR3');
  end; {case}
  end; {expr3}
  
begin {expression}
if fop <= 63
then expr1(fop)
else if fop <= 155
     then expr2(fop)
     else expr3(fop);
end; {expression}

                                                                                                                                                                                                                                  